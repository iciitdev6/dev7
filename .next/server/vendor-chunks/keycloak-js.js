"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/keycloak-js";
exports.ids = ["vendor-chunks/keycloak-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/keycloak-js/lib/keycloak.js":
/*!**************************************************!*\
  !*** ./node_modules/keycloak-js/lib/keycloak.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction Keycloak (config) {\n    if (!(this instanceof Keycloak)) {\n        throw new Error(\"The 'Keycloak' constructor must be invoked with 'new'.\")\n    }\n\n    if (typeof config !== 'string' && !isObject(config)) {\n        throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\");\n    }\n\n    if (isObject(config)) {\n        const requiredProperties = 'oidcProvider' in config\n            ? ['clientId']\n            : ['url', 'realm', 'clientId'];\n\n        for (const property of requiredProperties) {\n            if (!config[property]) {\n                throw new Error(`The configuration object is missing the required '${property}' property.`);\n            }\n        }\n    }\n\n    var kc = this;\n    var adapter;\n    var refreshQueue = [];\n    var callbackStorage;\n\n    var loginIframe = {\n        enable: true,\n        callbackList: [],\n        interval: 5\n    };\n\n    kc.didInitialize = false;\n\n    var useNonce = true;\n    var logInfo = createLogger(console.info);\n    var logWarn = createLogger(console.warn);\n\n    if (!globalThis.isSecureContext) {\n        logWarn(\n            \"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\n\" +\n            \"Continuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\n\" +\n            \"For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\"\n        );\n    }\n\n    kc.init = function (initOptions = {}) {\n        if (kc.didInitialize) {\n            throw new Error(\"A 'Keycloak' instance can only be initialized once.\");\n        }\n\n        kc.didInitialize = true;\n\n        kc.authenticated = false;\n\n        callbackStorage = createCallbackStorage();\n        var adapters = ['default', 'cordova', 'cordova-native'];\n\n        if (adapters.indexOf(initOptions.adapter) > -1) {\n            adapter = loadAdapter(initOptions.adapter);\n        } else if (typeof initOptions.adapter === \"object\") {\n            adapter = initOptions.adapter;\n        } else {\n            if (window.Cordova || window.cordova) {\n                adapter = loadAdapter('cordova');\n            } else {\n                adapter = loadAdapter();\n            }\n        }\n\n        if (typeof initOptions.useNonce !== 'undefined') {\n            useNonce = initOptions.useNonce;\n        }\n\n        if (typeof initOptions.checkLoginIframe !== 'undefined') {\n            loginIframe.enable = initOptions.checkLoginIframe;\n        }\n\n        if (initOptions.checkLoginIframeInterval) {\n            loginIframe.interval = initOptions.checkLoginIframeInterval;\n        }\n\n        if (initOptions.onLoad === 'login-required') {\n            kc.loginRequired = true;\n        }\n\n        if (initOptions.responseMode) {\n            if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') {\n                kc.responseMode = initOptions.responseMode;\n            } else {\n                throw 'Invalid value for responseMode';\n            }\n        }\n\n        if (initOptions.flow) {\n            switch (initOptions.flow) {\n                case 'standard':\n                    kc.responseType = 'code';\n                    break;\n                case 'implicit':\n                    kc.responseType = 'id_token token';\n                    break;\n                case 'hybrid':\n                    kc.responseType = 'code id_token token';\n                    break;\n                default:\n                    throw 'Invalid value for flow';\n            }\n            kc.flow = initOptions.flow;\n        }\n\n        if (initOptions.timeSkew != null) {\n            kc.timeSkew = initOptions.timeSkew;\n        }\n\n        if(initOptions.redirectUri) {\n            kc.redirectUri = initOptions.redirectUri;\n        }\n\n        if (initOptions.silentCheckSsoRedirectUri) {\n            kc.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;\n        }\n\n        if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n            kc.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;\n        } else {\n            kc.silentCheckSsoFallback = true;\n        }\n\n        if (typeof initOptions.pkceMethod !== \"undefined\") {\n            if (initOptions.pkceMethod !== \"S256\" && initOptions.pkceMethod !== false) {\n                throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`);\n            }\n\n            kc.pkceMethod = initOptions.pkceMethod;\n        } else {\n            kc.pkceMethod = \"S256\";\n        }\n\n        if (typeof initOptions.enableLogging === 'boolean') {\n            kc.enableLogging = initOptions.enableLogging;\n        } else {\n            kc.enableLogging = false;\n        }\n\n        if (initOptions.logoutMethod === 'POST') {\n            kc.logoutMethod = 'POST';\n        } else {\n            kc.logoutMethod = 'GET';\n        }\n\n        if (typeof initOptions.scope === 'string') {\n            kc.scope = initOptions.scope;\n        }\n\n        if (typeof initOptions.acrValues === 'string') {\n            kc.acrValues = initOptions.acrValues;\n        }\n\n        if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) {\n            kc.messageReceiveTimeout = initOptions.messageReceiveTimeout;\n        } else {\n            kc.messageReceiveTimeout = 10000;\n        }\n\n        if (!kc.responseMode) {\n            kc.responseMode = 'fragment';\n        }\n        if (!kc.responseType) {\n            kc.responseType = 'code';\n            kc.flow = 'standard';\n        }\n\n        var promise = createPromise();\n\n        var initPromise = createPromise();\n        initPromise.promise.then(function() {\n            kc.onReady && kc.onReady(kc.authenticated);\n            promise.setSuccess(kc.authenticated);\n        }).catch(function(error) {\n            promise.setError(error);\n        });\n\n        var configPromise = loadConfig();\n\n        function onLoad() {\n            var doLogin = function(prompt) {\n                if (!prompt) {\n                    options.prompt = 'none';\n                }\n\n                if (initOptions.locale) {\n                    options.locale = initOptions.locale;\n                }\n                kc.login(options).then(function () {\n                    initPromise.setSuccess();\n                }).catch(function (error) {\n                    initPromise.setError(error);\n                });\n            }\n\n            var checkSsoSilently = async function() {\n                var ifrm = document.createElement(\"iframe\");\n                var src = await kc.createLoginUrl({prompt: 'none', redirectUri: kc.silentCheckSsoRedirectUri});\n                ifrm.setAttribute(\"src\", src);\n                ifrm.setAttribute(\"sandbox\", \"allow-storage-access-by-user-activation allow-scripts allow-same-origin\");\n                ifrm.setAttribute(\"title\", \"keycloak-silent-check-sso\");\n                ifrm.style.display = \"none\";\n                document.body.appendChild(ifrm);\n\n                var messageCallback = function(event) {\n                    if (event.origin !== window.location.origin || ifrm.contentWindow !== event.source) {\n                        return;\n                    }\n\n                    var oauth = parseCallback(event.data);\n                    processCallback(oauth, initPromise);\n\n                    document.body.removeChild(ifrm);\n                    window.removeEventListener(\"message\", messageCallback);\n                };\n\n                window.addEventListener(\"message\", messageCallback);\n            };\n\n            var options = {};\n            switch (initOptions.onLoad) {\n                case 'check-sso':\n                    if (loginIframe.enable) {\n                        setupCheckLoginIframe().then(function() {\n                            checkLoginIframe().then(function (unchanged) {\n                                if (!unchanged) {\n                                    kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);\n                                } else {\n                                    initPromise.setSuccess();\n                                }\n                            }).catch(function (error) {\n                                initPromise.setError(error);\n                            });\n                        });\n                    } else {\n                        kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);\n                    }\n                    break;\n                case 'login-required':\n                    doLogin(true);\n                    break;\n                default:\n                    throw 'Invalid value for onLoad';\n            }\n        }\n\n        function processInit() {\n            var callback = parseCallback(window.location.href);\n\n            if (callback) {\n                window.history.replaceState(window.history.state, null, callback.newUrl);\n            }\n\n            if (callback && callback.valid) {\n                return setupCheckLoginIframe().then(function() {\n                    processCallback(callback, initPromise);\n                }).catch(function (error) {\n                    initPromise.setError(error);\n                });\n            }\n\n            if (initOptions.token && initOptions.refreshToken) {\n                setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken);\n\n                if (loginIframe.enable) {\n                    setupCheckLoginIframe().then(function() {\n                        checkLoginIframe().then(function (unchanged) {\n                            if (unchanged) {\n                                kc.onAuthSuccess && kc.onAuthSuccess();\n                                initPromise.setSuccess();\n                                scheduleCheckIframe();\n                            } else {\n                                initPromise.setSuccess();\n                            }\n                        }).catch(function (error) {\n                            initPromise.setError(error);\n                        });\n                    });\n                } else {\n                    kc.updateToken(-1).then(function() {\n                        kc.onAuthSuccess && kc.onAuthSuccess();\n                        initPromise.setSuccess();\n                    }).catch(function(error) {\n                        kc.onAuthError && kc.onAuthError();\n                        if (initOptions.onLoad) {\n                            onLoad();\n                        } else {\n                            initPromise.setError(error);\n                        }\n                    });\n                }\n            } else if (initOptions.onLoad) {\n                onLoad();\n            } else {\n                initPromise.setSuccess();\n            }\n        }\n\n        configPromise.then(function () {\n            check3pCookiesSupported()\n                .then(processInit)\n                .catch(function (error) {\n                    promise.setError(error);\n                });\n        });\n        configPromise.catch(function (error) {\n            promise.setError(error);\n        });\n\n        return promise.promise;\n    }\n\n    kc.login = function (options) {\n        return adapter.login(options);\n    }\n\n    function generateRandomData(len) {\n        if (typeof crypto === \"undefined\" || typeof crypto.getRandomValues === \"undefined\") {\n            throw new Error(\"Web Crypto API is not available.\");\n        }\n\n        return crypto.getRandomValues(new Uint8Array(len));\n    }\n\n    function generateCodeVerifier(len) {\n        return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n    }\n\n    function generateRandomString(len, alphabet){\n        var randomData = generateRandomData(len);\n        var chars = new Array(len);\n        for (var i = 0; i < len; i++) {\n            chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);\n        }\n        return String.fromCharCode.apply(null, chars);\n    }\n\n    async function generatePkceChallenge(pkceMethod, codeVerifier) {\n        if (pkceMethod !== \"S256\") {\n            throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`);\n        }\n\n        // hash codeVerifier, then encode as url-safe base64 without padding\n        const hashBytes = new Uint8Array(await sha256Digest(codeVerifier));\n        const encodedHash = bytesToBase64(hashBytes)\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/\\=/g, '');\n\n        return encodedHash;\n    }\n\n    function buildClaimsParameter(requestedAcr){\n        var claims = {\n            id_token: {\n                acr: requestedAcr\n            }\n        }\n        return JSON.stringify(claims);\n    }\n\n    kc.createLoginUrl = async function(options) {\n        var state = createUUID();\n        var nonce = createUUID();\n\n        var redirectUri = adapter.redirectUri(options);\n\n        var callbackState = {\n            state: state,\n            nonce: nonce,\n            redirectUri: encodeURIComponent(redirectUri),\n            loginOptions: options\n        };\n\n        if (options && options.prompt) {\n            callbackState.prompt = options.prompt;\n        }\n\n        var baseUrl;\n        if (options && options.action == 'register') {\n            baseUrl = kc.endpoints.register();\n        } else {\n            baseUrl = kc.endpoints.authorize();\n        }\n\n        var scope = options && options.scope || kc.scope;\n        if (!scope) {\n            // if scope is not set, default to \"openid\"\n            scope = \"openid\";\n        } else if (scope.indexOf(\"openid\") === -1) {\n            // if openid scope is missing, prefix the given scopes with it\n            scope = \"openid \" + scope;\n        }\n\n        var url = baseUrl\n            + '?client_id=' + encodeURIComponent(kc.clientId)\n            + '&redirect_uri=' + encodeURIComponent(redirectUri)\n            + '&state=' + encodeURIComponent(state)\n            + '&response_mode=' + encodeURIComponent(kc.responseMode)\n            + '&response_type=' + encodeURIComponent(kc.responseType)\n            + '&scope=' + encodeURIComponent(scope);\n        if (useNonce) {\n            url = url + '&nonce=' + encodeURIComponent(nonce);\n        }\n\n        if (options && options.prompt) {\n            url += '&prompt=' + encodeURIComponent(options.prompt);\n        }\n\n        if (options && typeof options.maxAge === 'number') {\n            url += '&max_age=' + encodeURIComponent(options.maxAge);\n        }\n\n        if (options && options.loginHint) {\n            url += '&login_hint=' + encodeURIComponent(options.loginHint);\n        }\n\n        if (options && options.idpHint) {\n            url += '&kc_idp_hint=' + encodeURIComponent(options.idpHint);\n        }\n\n        if (options && options.action && options.action != 'register') {\n            url += '&kc_action=' + encodeURIComponent(options.action);\n        }\n\n        if (options && options.locale) {\n            url += '&ui_locales=' + encodeURIComponent(options.locale);\n        }\n\n        if (options && options.acr) {\n            var claimsParameter = buildClaimsParameter(options.acr);\n            url += '&claims=' + encodeURIComponent(claimsParameter);\n        }\n\n        if ((options && options.acrValues) || kc.acrValues) {\n            url += '&acr_values=' + encodeURIComponent(options.acrValues || kc.acrValues);\n        }\n\n        if (kc.pkceMethod) {\n            try {\n                const codeVerifier = generateCodeVerifier(96);\n                const pkceChallenge = await generatePkceChallenge(kc.pkceMethod, codeVerifier);\n\n                callbackState.pkceCodeVerifier = codeVerifier;\n\n                url += '&code_challenge=' + pkceChallenge;\n                url += '&code_challenge_method=' + kc.pkceMethod;\n            } catch (error) {\n                throw new Error(\"Failed to generate PKCE challenge.\", { cause: error });\n            }\n        }\n\n        callbackStorage.add(callbackState);\n\n        return url;\n    }\n\n    kc.logout = function(options) {\n        return adapter.logout(options);\n    }\n\n    kc.createLogoutUrl = function(options) {\n\n        const logoutMethod = options?.logoutMethod ?? kc.logoutMethod;\n        if (logoutMethod === 'POST') {\n            return kc.endpoints.logout();\n        }\n\n        var url = kc.endpoints.logout()\n            + '?client_id=' + encodeURIComponent(kc.clientId)\n            + '&post_logout_redirect_uri=' + encodeURIComponent(adapter.redirectUri(options, false));\n\n        if (kc.idToken) {\n            url += '&id_token_hint=' + encodeURIComponent(kc.idToken);\n        }\n\n        return url;\n    }\n\n    kc.register = function (options) {\n        return adapter.register(options);\n    }\n\n    kc.createRegisterUrl = async function(options) {\n        if (!options) {\n            options = {};\n        }\n        options.action = 'register';\n        return await kc.createLoginUrl(options);\n    }\n\n    kc.createAccountUrl = function(options) {\n        var realm = getRealmUrl();\n        var url = undefined;\n        if (typeof realm !== 'undefined') {\n            url = realm\n            + '/account'\n            + '?referrer=' + encodeURIComponent(kc.clientId)\n            + '&referrer_uri=' + encodeURIComponent(adapter.redirectUri(options));\n        }\n        return url;\n    }\n\n    kc.accountManagement = function() {\n        return adapter.accountManagement();\n    }\n\n    kc.hasRealmRole = function (role) {\n        var access = kc.realmAccess;\n        return !!access && access.roles.indexOf(role) >= 0;\n    }\n\n    kc.hasResourceRole = function(role, resource) {\n        if (!kc.resourceAccess) {\n            return false;\n        }\n\n        var access = kc.resourceAccess[resource || kc.clientId];\n        return !!access && access.roles.indexOf(role) >= 0;\n    }\n\n    kc.loadUserProfile = function() {\n        var url = getRealmUrl() + '/account';\n        var req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.setRequestHeader('Accept', 'application/json');\n        req.setRequestHeader('Authorization', 'bearer ' + kc.token);\n\n        var promise = createPromise();\n\n        req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n                if (req.status == 200) {\n                    kc.profile = JSON.parse(req.responseText);\n                    promise.setSuccess(kc.profile);\n                } else {\n                    promise.setError();\n                }\n            }\n        }\n\n        req.send();\n\n        return promise.promise;\n    }\n\n    kc.loadUserInfo = function() {\n        var url = kc.endpoints.userinfo();\n        var req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.setRequestHeader('Accept', 'application/json');\n        req.setRequestHeader('Authorization', 'bearer ' + kc.token);\n\n        var promise = createPromise();\n\n        req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n                if (req.status == 200) {\n                    kc.userInfo = JSON.parse(req.responseText);\n                    promise.setSuccess(kc.userInfo);\n                } else {\n                    promise.setError();\n                }\n            }\n        }\n\n        req.send();\n\n        return promise.promise;\n    }\n\n    kc.isTokenExpired = function(minValidity) {\n        if (!kc.tokenParsed || (!kc.refreshToken && kc.flow != 'implicit' )) {\n            throw 'Not authenticated';\n        }\n\n        if (kc.timeSkew == null) {\n            logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set');\n            return true;\n        }\n\n        var expiresIn = kc.tokenParsed['exp'] - Math.ceil(new Date().getTime() / 1000) + kc.timeSkew;\n        if (minValidity) {\n            if (isNaN(minValidity)) {\n                throw 'Invalid minValidity';\n            }\n            expiresIn -= minValidity;\n        }\n        return expiresIn < 0;\n    }\n\n    kc.updateToken = function(minValidity) {\n        var promise = createPromise();\n\n        if (!kc.refreshToken) {\n            promise.setError();\n            return promise.promise;\n        }\n\n        minValidity = minValidity || 5;\n\n        var exec = function() {\n            var refreshToken = false;\n            if (minValidity == -1) {\n                refreshToken = true;\n                logInfo('[KEYCLOAK] Refreshing token: forced refresh');\n            } else if (!kc.tokenParsed || kc.isTokenExpired(minValidity)) {\n                refreshToken = true;\n                logInfo('[KEYCLOAK] Refreshing token: token expired');\n            }\n\n            if (!refreshToken) {\n                promise.setSuccess(false);\n            } else {\n                var params = 'grant_type=refresh_token&' + 'refresh_token=' + kc.refreshToken;\n                var url = kc.endpoints.token();\n\n                refreshQueue.push(promise);\n\n                if (refreshQueue.length == 1) {\n                    var req = new XMLHttpRequest();\n                    req.open('POST', url, true);\n                    req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n                    req.withCredentials = true;\n\n                    params += '&client_id=' + encodeURIComponent(kc.clientId);\n\n                    var timeLocal = new Date().getTime();\n\n                    req.onreadystatechange = function () {\n                        if (req.readyState == 4) {\n                            if (req.status == 200) {\n                                logInfo('[KEYCLOAK] Token refreshed');\n\n                                timeLocal = (timeLocal + new Date().getTime()) / 2;\n\n                                var tokenResponse = JSON.parse(req.responseText);\n\n                                setToken(tokenResponse['access_token'], tokenResponse['refresh_token'], tokenResponse['id_token'], timeLocal);\n\n                                kc.onAuthRefreshSuccess && kc.onAuthRefreshSuccess();\n                                for (var p = refreshQueue.pop(); p != null; p = refreshQueue.pop()) {\n                                    p.setSuccess(true);\n                                }\n                            } else {\n                                logWarn('[KEYCLOAK] Failed to refresh token');\n\n                                if (req.status == 400) {\n                                    kc.clearToken();\n                                }\n\n                                kc.onAuthRefreshError && kc.onAuthRefreshError();\n                                for (var p = refreshQueue.pop(); p != null; p = refreshQueue.pop()) {\n                                    p.setError(\"Failed to refresh token: An unexpected HTTP error occurred while attempting to refresh the token.\");\n                                }\n                            }\n                        }\n                    };\n\n                    req.send(params);\n                }\n            }\n        }\n\n        if (loginIframe.enable) {\n            var iframePromise = checkLoginIframe();\n            iframePromise.then(function() {\n                exec();\n            }).catch(function(error) {\n                promise.setError(error);\n            });\n        } else {\n            exec();\n        }\n\n        return promise.promise;\n    }\n\n    kc.clearToken = function() {\n        if (kc.token) {\n            setToken(null, null, null);\n            kc.onAuthLogout && kc.onAuthLogout();\n            if (kc.loginRequired) {\n                kc.login();\n            }\n        }\n    }\n\n    function getRealmUrl() {\n        if (typeof kc.authServerUrl !== 'undefined') {\n            if (kc.authServerUrl.charAt(kc.authServerUrl.length - 1) == '/') {\n                return kc.authServerUrl + 'realms/' + encodeURIComponent(kc.realm);\n            } else {\n                return kc.authServerUrl + '/realms/' + encodeURIComponent(kc.realm);\n            }\n        } else {\n            return undefined;\n        }\n    }\n\n    function getOrigin() {\n        if (!window.location.origin) {\n            return window.location.protocol + \"//\" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');\n        } else {\n            return window.location.origin;\n        }\n    }\n\n    function processCallback(oauth, promise) {\n        var code = oauth.code;\n        var error = oauth.error;\n        var prompt = oauth.prompt;\n\n        var timeLocal = new Date().getTime();\n\n        if (oauth['kc_action_status']) {\n            kc.onActionUpdate && kc.onActionUpdate(oauth['kc_action_status'], oauth['kc_action']);\n        }\n\n        if (error) {\n            if (prompt != 'none') {\n                if (oauth.error_description && oauth.error_description === \"authentication_expired\") {\n                    kc.login(oauth.loginOptions);\n                } else {\n                    var errorData = { error: error, error_description: oauth.error_description };\n                    kc.onAuthError && kc.onAuthError(errorData);\n                    promise && promise.setError(errorData);\n                }\n            } else {\n                promise && promise.setSuccess();\n            }\n            return;\n        } else if ((kc.flow != 'standard') && (oauth.access_token || oauth.id_token)) {\n            authSuccess(oauth.access_token, null, oauth.id_token, true);\n        }\n\n        if ((kc.flow != 'implicit') && code) {\n            var params = 'code=' + code + '&grant_type=authorization_code';\n            var url = kc.endpoints.token();\n\n            var req = new XMLHttpRequest();\n            req.open('POST', url, true);\n            req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n\n            params += '&client_id=' + encodeURIComponent(kc.clientId);\n            params += '&redirect_uri=' + oauth.redirectUri;\n\n            if (oauth.pkceCodeVerifier) {\n                params += '&code_verifier=' + oauth.pkceCodeVerifier;\n            }\n\n            req.withCredentials = true;\n\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (req.status == 200) {\n\n                        var tokenResponse = JSON.parse(req.responseText);\n                        authSuccess(tokenResponse['access_token'], tokenResponse['refresh_token'], tokenResponse['id_token'], kc.flow === 'standard');\n                        scheduleCheckIframe();\n                    } else {\n                        kc.onAuthError && kc.onAuthError();\n                        promise && promise.setError();\n                    }\n                }\n            };\n\n            req.send(params);\n        }\n\n        function authSuccess(accessToken, refreshToken, idToken, fulfillPromise) {\n            timeLocal = (timeLocal + new Date().getTime()) / 2;\n\n            setToken(accessToken, refreshToken, idToken, timeLocal);\n\n            if (useNonce && (kc.idTokenParsed && kc.idTokenParsed.nonce != oauth.storedNonce)) {\n                logInfo('[KEYCLOAK] Invalid nonce, clearing token');\n                kc.clearToken();\n                promise && promise.setError();\n            } else {\n                if (fulfillPromise) {\n                    kc.onAuthSuccess && kc.onAuthSuccess();\n                    promise && promise.setSuccess();\n                }\n            }\n        }\n\n    }\n\n    function loadConfig() {\n        var promise = createPromise();\n        var configUrl;\n\n        if (typeof config === 'string') {\n            configUrl = config;\n        }\n\n        function setupOidcEndoints(oidcConfiguration) {\n            if (! oidcConfiguration) {\n                kc.endpoints = {\n                    authorize: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/auth';\n                    },\n                    token: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/token';\n                    },\n                    logout: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/logout';\n                    },\n                    checkSessionIframe: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html';\n                    },\n                    thirdPartyCookiesIframe: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html';\n                    },\n                    register: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/registrations';\n                    },\n                    userinfo: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/userinfo';\n                    }\n                };\n            } else {\n                kc.endpoints = {\n                    authorize: function() {\n                        return oidcConfiguration.authorization_endpoint;\n                    },\n                    token: function() {\n                        return oidcConfiguration.token_endpoint;\n                    },\n                    logout: function() {\n                        if (!oidcConfiguration.end_session_endpoint) {\n                            throw \"Not supported by the OIDC server\";\n                        }\n                        return oidcConfiguration.end_session_endpoint;\n                    },\n                    checkSessionIframe: function() {\n                        if (!oidcConfiguration.check_session_iframe) {\n                            throw \"Not supported by the OIDC server\";\n                        }\n                        return oidcConfiguration.check_session_iframe;\n                    },\n                    register: function() {\n                        throw 'Redirection to \"Register user\" page not supported in standard OIDC mode';\n                    },\n                    userinfo: function() {\n                        if (!oidcConfiguration.userinfo_endpoint) {\n                            throw \"Not supported by the OIDC server\";\n                        }\n                        return oidcConfiguration.userinfo_endpoint;\n                    }\n                }\n            }\n        }\n\n        if (configUrl) {\n            var req = new XMLHttpRequest();\n            req.open('GET', configUrl, true);\n            req.setRequestHeader('Accept', 'application/json');\n\n            req.onreadystatechange = function () {\n                if (req.readyState == 4) {\n                    if (req.status == 200 || fileLoaded(req)) {\n                        var config = JSON.parse(req.responseText);\n\n                        kc.authServerUrl = config['auth-server-url'];\n                        kc.realm = config['realm'];\n                        kc.clientId = config['resource'];\n                        setupOidcEndoints(null);\n                        promise.setSuccess();\n                    } else {\n                        promise.setError();\n                    }\n                }\n            };\n\n            req.send();\n        } else {\n            kc.clientId = config.clientId;\n\n            var oidcProvider = config['oidcProvider'];\n            if (!oidcProvider) {\n                kc.authServerUrl = config.url;\n                kc.realm = config.realm;\n                setupOidcEndoints(null);\n                promise.setSuccess();\n            } else {\n                if (typeof oidcProvider === 'string') {\n                    var oidcProviderConfigUrl;\n                    if (oidcProvider.charAt(oidcProvider.length - 1) == '/') {\n                        oidcProviderConfigUrl = oidcProvider + '.well-known/openid-configuration';\n                    } else {\n                        oidcProviderConfigUrl = oidcProvider + '/.well-known/openid-configuration';\n                    }\n                    var req = new XMLHttpRequest();\n                    req.open('GET', oidcProviderConfigUrl, true);\n                    req.setRequestHeader('Accept', 'application/json');\n\n                    req.onreadystatechange = function () {\n                        if (req.readyState == 4) {\n                            if (req.status == 200 || fileLoaded(req)) {\n                                var oidcProviderConfig = JSON.parse(req.responseText);\n                                setupOidcEndoints(oidcProviderConfig);\n                                promise.setSuccess();\n                            } else {\n                                promise.setError();\n                            }\n                        }\n                    };\n\n                    req.send();\n                } else {\n                    setupOidcEndoints(oidcProvider);\n                    promise.setSuccess();\n                }\n            }\n        }\n\n        return promise.promise;\n    }\n\n    function fileLoaded(xhr) {\n        return xhr.status == 0 && xhr.responseText && xhr.responseURL.startsWith('file:');\n    }\n\n    function setToken(token, refreshToken, idToken, timeLocal) {\n        if (kc.tokenTimeoutHandle) {\n            clearTimeout(kc.tokenTimeoutHandle);\n            kc.tokenTimeoutHandle = null;\n        }\n\n        if (refreshToken) {\n            kc.refreshToken = refreshToken;\n            kc.refreshTokenParsed = decodeToken(refreshToken);\n        } else {\n            delete kc.refreshToken;\n            delete kc.refreshTokenParsed;\n        }\n\n        if (idToken) {\n            kc.idToken = idToken;\n            kc.idTokenParsed = decodeToken(idToken);\n        } else {\n            delete kc.idToken;\n            delete kc.idTokenParsed;\n        }\n\n        if (token) {\n            kc.token = token;\n            kc.tokenParsed = decodeToken(token);\n            kc.sessionId = kc.tokenParsed.sid;\n            kc.authenticated = true;\n            kc.subject = kc.tokenParsed.sub;\n            kc.realmAccess = kc.tokenParsed.realm_access;\n            kc.resourceAccess = kc.tokenParsed.resource_access;\n\n            if (timeLocal) {\n                kc.timeSkew = Math.floor(timeLocal / 1000) - kc.tokenParsed.iat;\n            }\n\n            if (kc.timeSkew != null) {\n                logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + kc.timeSkew + ' seconds');\n\n                if (kc.onTokenExpired) {\n                    var expiresIn = (kc.tokenParsed['exp'] - (new Date().getTime() / 1000) + kc.timeSkew) * 1000;\n                    logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s');\n                    if (expiresIn <= 0) {\n                        kc.onTokenExpired();\n                    } else {\n                        kc.tokenTimeoutHandle = setTimeout(kc.onTokenExpired, expiresIn);\n                    }\n                }\n            }\n        } else {\n            delete kc.token;\n            delete kc.tokenParsed;\n            delete kc.subject;\n            delete kc.realmAccess;\n            delete kc.resourceAccess;\n\n            kc.authenticated = false;\n        }\n    }\n\n    function createUUID() {\n        if (typeof crypto === \"undefined\" || typeof crypto.randomUUID === \"undefined\") {\n            throw new Error(\"Web Crypto API is not available.\");\n        }\n\n        return crypto.randomUUID();\n    }\n\n    function parseCallback(url) {\n        var oauth = parseCallbackUrl(url);\n        if (!oauth) {\n            return;\n        }\n\n        var oauthState = callbackStorage.get(oauth.state);\n\n        if (oauthState) {\n            oauth.valid = true;\n            oauth.redirectUri = oauthState.redirectUri;\n            oauth.storedNonce = oauthState.nonce;\n            oauth.prompt = oauthState.prompt;\n            oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;\n            oauth.loginOptions = oauthState.loginOptions;\n        }\n\n        return oauth;\n    }\n\n    function parseCallbackUrl(url) {\n        var supportedParams;\n        switch (kc.flow) {\n            case 'standard':\n                supportedParams = ['code', 'state', 'session_state', 'kc_action_status', 'kc_action', 'iss'];\n                break;\n            case 'implicit':\n                supportedParams = ['access_token', 'token_type', 'id_token', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n                break;\n            case 'hybrid':\n                supportedParams = ['access_token', 'token_type', 'id_token', 'code', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n                break;\n        }\n\n        supportedParams.push('error');\n        supportedParams.push('error_description');\n        supportedParams.push('error_uri');\n\n        var queryIndex = url.indexOf('?');\n        var fragmentIndex = url.indexOf('#');\n\n        var newUrl;\n        var parsed;\n\n        if (kc.responseMode === 'query' && queryIndex !== -1) {\n            newUrl = url.substring(0, queryIndex);\n            parsed = parseCallbackParams(url.substring(queryIndex + 1, fragmentIndex !== -1 ? fragmentIndex : url.length), supportedParams);\n            if (parsed.paramsString !== '') {\n                newUrl += '?' + parsed.paramsString;\n            }\n            if (fragmentIndex !== -1) {\n                newUrl += url.substring(fragmentIndex);\n            }\n        } else if (kc.responseMode === 'fragment' && fragmentIndex !== -1) {\n            newUrl = url.substring(0, fragmentIndex);\n            parsed = parseCallbackParams(url.substring(fragmentIndex + 1), supportedParams);\n            if (parsed.paramsString !== '') {\n                newUrl += '#' + parsed.paramsString;\n            }\n        }\n\n        if (parsed && parsed.oauthParams) {\n            if (kc.flow === 'standard' || kc.flow === 'hybrid') {\n                if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n                    parsed.oauthParams.newUrl = newUrl;\n                    return parsed.oauthParams;\n                }\n            } else if (kc.flow === 'implicit') {\n                if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n                    parsed.oauthParams.newUrl = newUrl;\n                    return parsed.oauthParams;\n                }\n            }\n        }\n    }\n\n    function parseCallbackParams(paramsString, supportedParams) {\n        var p = paramsString.split('&');\n        var result = {\n            paramsString: '',\n            oauthParams: {}\n        }\n        for (var i = 0; i < p.length; i++) {\n            var split = p[i].indexOf(\"=\");\n            var key = p[i].slice(0, split);\n            if (supportedParams.indexOf(key) !== -1) {\n                result.oauthParams[key] = p[i].slice(split + 1);\n            } else {\n                if (result.paramsString !== '') {\n                    result.paramsString += '&';\n                }\n                result.paramsString += p[i];\n            }\n        }\n        return result;\n    }\n\n    function createPromise() {\n        // Need to create a native Promise which also preserves the\n        // interface of the custom promise type previously used by the API\n        var p = {\n            setSuccess: function(result) {\n                p.resolve(result);\n            },\n\n            setError: function(result) {\n                p.reject(result);\n            }\n        };\n        p.promise = new Promise(function(resolve, reject) {\n            p.resolve = resolve;\n            p.reject = reject;\n        });\n\n        return p;\n    }\n\n    // Function to extend existing native Promise with timeout\n    function applyTimeoutToPromise(promise, timeout, errorMessage) {\n        var timeoutHandle = null;\n        var timeoutPromise = new Promise(function (resolve, reject) {\n            timeoutHandle = setTimeout(function () {\n                reject({ \"error\": errorMessage || \"Promise is not settled within timeout of \" + timeout + \"ms\" });\n            }, timeout);\n        });\n\n        return Promise.race([promise, timeoutPromise]).finally(function () {\n            clearTimeout(timeoutHandle);\n        });\n    }\n\n    function setupCheckLoginIframe() {\n        var promise = createPromise();\n\n        if (!loginIframe.enable) {\n            promise.setSuccess();\n            return promise.promise;\n        }\n\n        if (loginIframe.iframe) {\n            promise.setSuccess();\n            return promise.promise;\n        }\n\n        var iframe = document.createElement('iframe');\n        loginIframe.iframe = iframe;\n\n        iframe.onload = function() {\n            var authUrl = kc.endpoints.authorize();\n            if (authUrl.charAt(0) === '/') {\n                loginIframe.iframeOrigin = getOrigin();\n            } else {\n                loginIframe.iframeOrigin = authUrl.substring(0, authUrl.indexOf('/', 8));\n            }\n            promise.setSuccess();\n        }\n\n        var src = kc.endpoints.checkSessionIframe();\n        iframe.setAttribute('src', src );\n        iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n        iframe.setAttribute('title', 'keycloak-session-iframe' );\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n\n        var messageCallback = function(event) {\n            if ((event.origin !== loginIframe.iframeOrigin) || (loginIframe.iframe.contentWindow !== event.source)) {\n                return;\n            }\n\n            if (!(event.data == 'unchanged' || event.data == 'changed' || event.data == 'error')) {\n                return;\n            }\n\n\n            if (event.data != 'unchanged') {\n                kc.clearToken();\n            }\n\n            var callbacks = loginIframe.callbackList.splice(0, loginIframe.callbackList.length);\n\n            for (var i = callbacks.length - 1; i >= 0; --i) {\n                var promise = callbacks[i];\n                if (event.data == 'error') {\n                    promise.setError();\n                } else {\n                    promise.setSuccess(event.data == 'unchanged');\n                }\n            }\n        };\n\n        window.addEventListener('message', messageCallback, false);\n\n        return promise.promise;\n    }\n\n    function scheduleCheckIframe() {\n        if (loginIframe.enable) {\n            if (kc.token) {\n                setTimeout(function() {\n                    checkLoginIframe().then(function(unchanged) {\n                        if (unchanged) {\n                            scheduleCheckIframe();\n                        }\n                    });\n                }, loginIframe.interval * 1000);\n            }\n        }\n    }\n\n    function checkLoginIframe() {\n        var promise = createPromise();\n\n        if (loginIframe.iframe && loginIframe.iframeOrigin ) {\n            var msg = kc.clientId + ' ' + (kc.sessionId ? kc.sessionId : '');\n            loginIframe.callbackList.push(promise);\n            var origin = loginIframe.iframeOrigin;\n            if (loginIframe.callbackList.length == 1) {\n                loginIframe.iframe.contentWindow.postMessage(msg, origin);\n            }\n        } else {\n            promise.setSuccess();\n        }\n\n        return promise.promise;\n    }\n\n    function check3pCookiesSupported() {\n        var promise = createPromise();\n\n        if ((loginIframe.enable || kc.silentCheckSsoRedirectUri) && typeof kc.endpoints.thirdPartyCookiesIframe === 'function') {\n            var iframe = document.createElement('iframe');\n            iframe.setAttribute('src', kc.endpoints.thirdPartyCookiesIframe());\n            iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n            iframe.setAttribute('title', 'keycloak-3p-check-iframe' );\n            iframe.style.display = 'none';\n            document.body.appendChild(iframe);\n\n            var messageCallback = function(event) {\n                if (iframe.contentWindow !== event.source) {\n                    return;\n                }\n\n                if (event.data !== \"supported\" && event.data !== \"unsupported\") {\n                    return;\n                } else if (event.data === \"unsupported\") {\n                    logWarn(\n                        \"[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n\" +\n                        \" - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n\" +\n                        \" - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\n\" +\n                        \"For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers\"\n                    );\n\n                    loginIframe.enable = false;\n                    if (kc.silentCheckSsoFallback) {\n                        kc.silentCheckSsoRedirectUri = false;\n                    }\n                }\n\n                document.body.removeChild(iframe);\n                window.removeEventListener(\"message\", messageCallback);\n                promise.setSuccess();\n            };\n\n            window.addEventListener('message', messageCallback, false);\n        } else {\n            promise.setSuccess();\n        }\n\n        return applyTimeoutToPromise(promise.promise, kc.messageReceiveTimeout, \"Timeout when waiting for 3rd party check iframe message.\");\n    }\n\n    function loadAdapter(type) {\n        if (!type || type == 'default') {\n            return {\n                login: async function(options) {\n                    window.location.assign(await kc.createLoginUrl(options));\n                    return createPromise().promise;\n                },\n\n                logout: async function(options) {\n\n                    const logoutMethod = options?.logoutMethod ?? kc.logoutMethod;\n                    if (logoutMethod === \"GET\") {\n                        window.location.replace(kc.createLogoutUrl(options));\n                        return;\n                    }\n\n                    // Create form to send POST request.\n                    const form = document.createElement(\"form\");\n\n                    form.setAttribute(\"method\", \"POST\");\n                    form.setAttribute(\"action\", kc.createLogoutUrl(options));\n                    form.style.display = \"none\";\n\n                    // Add data to form as hidden input fields.\n                    const data = {\n                        id_token_hint: kc.idToken,\n                        client_id: kc.clientId,\n                        post_logout_redirect_uri: adapter.redirectUri(options, false)\n                    };\n\n                    for (const [name, value] of Object.entries(data)) {\n                        const input = document.createElement(\"input\");\n\n                        input.setAttribute(\"type\", \"hidden\");\n                        input.setAttribute(\"name\", name);\n                        input.setAttribute(\"value\", value);\n\n                        form.appendChild(input);\n                    }\n\n                    // Append form to page and submit it to perform logout and redirect.\n                    document.body.appendChild(form);\n                    form.submit();\n                },\n\n                register: async function(options) {\n                    window.location.assign(await kc.createRegisterUrl(options));\n                    return createPromise().promise;\n                },\n\n                accountManagement : function() {\n                    var accountUrl = kc.createAccountUrl();\n                    if (typeof accountUrl !== 'undefined') {\n                        window.location.href = accountUrl;\n                    } else {\n                        throw \"Not supported by the OIDC server\";\n                    }\n                    return createPromise().promise;\n                },\n\n                redirectUri: function(options, encodeHash) {\n                    if (arguments.length == 1) {\n                        encodeHash = true;\n                    }\n\n                    if (options && options.redirectUri) {\n                        return options.redirectUri;\n                    } else if (kc.redirectUri) {\n                        return kc.redirectUri;\n                    } else {\n                        return location.href;\n                    }\n                }\n            };\n        }\n\n        if (type == 'cordova') {\n            loginIframe.enable = false;\n            var cordovaOpenWindowWrapper = function(loginUrl, target, options) {\n                if (window.cordova && window.cordova.InAppBrowser) {\n                    // Use inappbrowser for IOS and Android if available\n                    return window.cordova.InAppBrowser.open(loginUrl, target, options);\n                } else {\n                    return window.open(loginUrl, target, options);\n                }\n            };\n\n            var shallowCloneCordovaOptions = function (userOptions) {\n                if (userOptions && userOptions.cordovaOptions) {\n                    return Object.keys(userOptions.cordovaOptions).reduce(function (options, optionName) {\n                        options[optionName] = userOptions.cordovaOptions[optionName];\n                        return options;\n                    }, {});\n                } else {\n                    return {};\n                }\n            };\n\n            var formatCordovaOptions = function (cordovaOptions) {\n                return Object.keys(cordovaOptions).reduce(function (options, optionName) {\n                    options.push(optionName+\"=\"+cordovaOptions[optionName]);\n                    return options;\n                }, []).join(\",\");\n            };\n\n            var createCordovaOptions = function (userOptions) {\n                var cordovaOptions = shallowCloneCordovaOptions(userOptions);\n                cordovaOptions.location = 'no';\n                if (userOptions && userOptions.prompt == 'none') {\n                    cordovaOptions.hidden = 'yes';\n                }\n                return formatCordovaOptions(cordovaOptions);\n            };\n\n            var getCordovaRedirectUri = function() {\n                return kc.redirectUri || 'http://localhost';\n            }\n\n            return {\n                login: async function(options) {\n                    var promise = createPromise();\n\n                    var cordovaOptions = createCordovaOptions(options);\n                    var loginUrl = await kc.createLoginUrl(options);\n                    var ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions);\n                    var completed = false;\n\n                    var closed = false;\n                    var closeBrowser = function() {\n                        closed = true;\n                        ref.close();\n                    };\n\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            var callback = parseCallback(event.url);\n                            processCallback(callback, promise);\n                            closeBrowser();\n                            completed = true;\n                        }\n                    });\n\n                    ref.addEventListener('loaderror', function(event) {\n                        if (!completed) {\n                            if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                                var callback = parseCallback(event.url);\n                                processCallback(callback, promise);\n                                closeBrowser();\n                                completed = true;\n                            } else {\n                                promise.setError();\n                                closeBrowser();\n                            }\n                        }\n                    });\n\n                    ref.addEventListener('exit', function(event) {\n                        if (!closed) {\n                            promise.setError({\n                                reason: \"closed_by_user\"\n                            });\n                        }\n                    });\n\n                    return promise.promise;\n                },\n\n                logout: function(options) {\n                    var promise = createPromise();\n\n                    var logoutUrl = kc.createLogoutUrl(options);\n                    var ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes');\n\n                    var error;\n\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            ref.close();\n                        }\n                    });\n\n                    ref.addEventListener('loaderror', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            ref.close();\n                        } else {\n                            error = true;\n                            ref.close();\n                        }\n                    });\n\n                    ref.addEventListener('exit', function(event) {\n                        if (error) {\n                            promise.setError();\n                        } else {\n                            kc.clearToken();\n                            promise.setSuccess();\n                        }\n                    });\n\n                    return promise.promise;\n                },\n\n                register : async function(options) {\n                    var promise = createPromise();\n                    var registerUrl = await kc.createRegisterUrl();\n                    var cordovaOptions = createCordovaOptions(options);\n                    var ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions);\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            ref.close();\n                            var oauth = parseCallback(event.url);\n                            processCallback(oauth, promise);\n                        }\n                    });\n                    return promise.promise;\n                },\n\n                accountManagement : function() {\n                    var accountUrl = kc.createAccountUrl();\n                    if (typeof accountUrl !== 'undefined') {\n                        var ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no');\n                        ref.addEventListener('loadstart', function(event) {\n                            if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                                ref.close();\n                            }\n                        });\n                    } else {\n                        throw \"Not supported by the OIDC server\";\n                    }\n                },\n\n                redirectUri: function(options) {\n                    return getCordovaRedirectUri();\n                }\n            }\n        }\n\n        if (type == 'cordova-native') {\n            loginIframe.enable = false;\n\n            return {\n                login: async function(options) {\n                    var promise = createPromise();\n                    var loginUrl = await kc.createLoginUrl(options);\n\n                    universalLinks.subscribe('keycloak', function(event) {\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        var oauth = parseCallback(event.url);\n                        processCallback(oauth, promise);\n                    });\n\n                    window.cordova.plugins.browsertab.openUrl(loginUrl);\n                    return promise.promise;\n                },\n\n                logout: function(options) {\n                    var promise = createPromise();\n                    var logoutUrl = kc.createLogoutUrl(options);\n\n                    universalLinks.subscribe('keycloak', function(event) {\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        kc.clearToken();\n                        promise.setSuccess();\n                    });\n\n                    window.cordova.plugins.browsertab.openUrl(logoutUrl);\n                    return promise.promise;\n                },\n\n                register : async function(options) {\n                    var promise = createPromise();\n                    var registerUrl = await kc.createRegisterUrl(options);\n                    universalLinks.subscribe('keycloak' , function(event) {\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        var oauth = parseCallback(event.url);\n                        processCallback(oauth, promise);\n                    });\n                    window.cordova.plugins.browsertab.openUrl(registerUrl);\n                    return promise.promise;\n\n                },\n\n                accountManagement : function() {\n                    var accountUrl = kc.createAccountUrl();\n                    if (typeof accountUrl !== 'undefined') {\n                        window.cordova.plugins.browsertab.openUrl(accountUrl);\n                    } else {\n                        throw \"Not supported by the OIDC server\";\n                    }\n                },\n\n                redirectUri: function(options) {\n                    if (options && options.redirectUri) {\n                        return options.redirectUri;\n                    } else if (kc.redirectUri) {\n                        return kc.redirectUri;\n                    } else {\n                        return \"http://localhost\";\n                    }\n                }\n            }\n        }\n\n        throw 'invalid adapter type: ' + type;\n    }\n\n    const STORAGE_KEY_PREFIX = 'kc-callback-';\n\n    var LocalStorage = function() {\n        if (!(this instanceof LocalStorage)) {\n            return new LocalStorage();\n        }\n\n        localStorage.setItem('kc-test', 'test');\n        localStorage.removeItem('kc-test');\n\n        var cs = this;\n\n        /**\n         * Clears all values from local storage that are no longer valid.\n         */\n        function clearInvalidValues() {\n            const currentTime = Date.now();\n\n            for (const [key, value] of getStoredEntries()) {\n                // Attempt to parse the expiry time from the value.\n                const expiry = parseExpiry(value);\n\n                // Discard the value if it is malformed or expired.\n                if (expiry === null || expiry < currentTime) {\n                    localStorage.removeItem(key);\n                }\n            }\n        }\n\n        /**\n         * Clears all known values from local storage.\n         */\n        function clearAllValues() {\n            for (const [key] of getStoredEntries()) {\n                localStorage.removeItem(key);\n            }\n        }\n\n        /**\n         * Gets all entries stored in local storage that are known to be managed by this class.\n         * @returns {Array<[string, unknown]>} An array of key-value pairs.\n         */\n        function getStoredEntries() {\n            return Object.entries(localStorage).filter(([key]) => key.startsWith(STORAGE_KEY_PREFIX));\n        }\n\n        /**\n         * Parses the expiry time from a value stored in local storage.\n         * @param {unknown} value\n         * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n         */\n        function parseExpiry(value) {\n            let parsedValue;\n\n            // Attempt to parse the value as JSON.\n            try {\n                parsedValue = JSON.parse(value);\n            } catch (error) {\n                return null;\n            }\n\n            // Attempt to extract the 'expires' property.\n            if (isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') {\n                return parsedValue.expires;\n            }\n\n            return null;\n        }\n\n        cs.get = function(state) {\n            if (!state) {\n                return;\n            }\n\n            var key = STORAGE_KEY_PREFIX + state;\n            var value = localStorage.getItem(key);\n            if (value) {\n                localStorage.removeItem(key);\n                value = JSON.parse(value);\n            }\n\n            clearInvalidValues();\n            return value;\n        };\n\n        cs.add = function(state) {\n            clearInvalidValues();\n\n            const key = STORAGE_KEY_PREFIX + state.state;\n            const value = JSON.stringify({\n                ...state,\n                // Set the expiry time to 1 hour from now.\n                expires: Date.now() + (60 * 60 * 1000)\n            });\n\n            try {\n                localStorage.setItem(key, value);\n            } catch (error) {\n                // If the storage is full, clear all known values and try again.\n                clearAllValues();\n                localStorage.setItem(key, value);\n            }\n        };\n    };\n\n    var CookieStorage = function() {\n        if (!(this instanceof CookieStorage)) {\n            return new CookieStorage();\n        }\n\n        var cs = this;\n\n        cs.get = function(state) {\n            if (!state) {\n                return;\n            }\n\n            var value = getCookie(STORAGE_KEY_PREFIX + state);\n            setCookie(STORAGE_KEY_PREFIX + state, '', cookieExpiration(-100));\n            if (value) {\n                return JSON.parse(value);\n            }\n        };\n\n        cs.add = function(state) {\n            setCookie(STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), cookieExpiration(60));\n        };\n\n        cs.removeItem = function(key) {\n            setCookie(key, '', cookieExpiration(-100));\n        };\n\n        var cookieExpiration = function (minutes) {\n            var exp = new Date();\n            exp.setTime(exp.getTime() + (minutes*60*1000));\n            return exp;\n        };\n\n        var getCookie = function (key) {\n            var name = key + '=';\n            var ca = document.cookie.split(';');\n            for (var i = 0; i < ca.length; i++) {\n                var c = ca[i];\n                while (c.charAt(0) == ' ') {\n                    c = c.substring(1);\n                }\n                if (c.indexOf(name) == 0) {\n                    return c.substring(name.length, c.length);\n                }\n            }\n            return '';\n        };\n\n        var setCookie = function (key, value, expirationDate) {\n            var cookie = key + '=' + value + '; '\n                + 'expires=' + expirationDate.toUTCString() + '; ';\n            document.cookie = cookie;\n        }\n    };\n\n    function createCallbackStorage() {\n        try {\n            return new LocalStorage();\n        } catch (err) {\n        }\n\n        return new CookieStorage();\n    }\n\n    function createLogger(fn) {\n        return function() {\n            if (kc.enableLogging) {\n                fn.apply(console, Array.prototype.slice.call(arguments));\n            }\n        };\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Keycloak);\n\n/**\n * @param {ArrayBuffer} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */\nfunction bytesToBase64(bytes) {\n    const binString = String.fromCodePoint(...bytes);\n    return btoa(binString);\n}\n\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */\nasync function sha256Digest(message) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n\n    if (typeof crypto === \"undefined\" || typeof crypto.subtle === \"undefined\") {\n        throw new Error(\"Web Crypto API is not available.\");\n    }\n\n    return await crypto.subtle.digest(\"SHA-256\", data);\n}\n\n/**\n * @param {string} token\n */\nfunction decodeToken(token) {\n    const [header, payload] = token.split(\".\");\n\n    if (typeof payload !== \"string\") {\n        throw new Error(\"Unable to decode token, payload not found.\");\n    }\n\n    let decoded;\n\n    try {\n        decoded = base64UrlDecode(payload);\n    } catch (error) {\n        throw new Error(\"Unable to decode token, payload is not a valid Base64URL value.\", { cause: error });\n    }\n\n    try {\n        return JSON.parse(decoded);\n    } catch (error) {\n        throw new Error(\"Unable to decode token, payload is not a valid JSON value.\", { cause: error });\n    }\n}\n\n/**\n * @param {string} input\n */\nfunction base64UrlDecode(input) {\n    let output = input\n        .replaceAll(\"-\", \"+\")\n        .replaceAll(\"_\", \"/\");\n\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"Input is not of the correct length.\");\n    }\n\n    try {\n        return b64DecodeUnicode(output);\n    } catch (error) {\n        return atob(output);\n    }\n}\n\n/**\n * @param {string} input\n */\nfunction b64DecodeUnicode(input) {\n    return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n\n        return \"%\" + code;\n    }));\n}\n\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */\nfunction isObject(input) {\n    return typeof input === 'object' && input !== null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMva2V5Y2xvYWstanMvbGliL2tleWNsb2FrLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUZBQXFGLFNBQVM7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUdBQXVHLHVCQUF1QjtBQUM5SDs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELDBEQUEwRDtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRGQUE0RixXQUFXO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHdFQUF3RSxjQUFjO0FBQ3RGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUZBQXVGO0FBQ2hILGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hELGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxRQUFRLEVBQUM7O0FBRXhCO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTiw2RkFBNkYsY0FBYztBQUMzRzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdGQUF3RixjQUFjO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMva2V5Y2xvYWstanMvbGliL2tleWNsb2FrLmpzPzdhODYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDE2IFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzXG4gKiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIGFzIGluZGljYXRlZCBieSB0aGUgQGF1dGhvciB0YWdzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBLZXljbG9hayAoY29uZmlnKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEtleWNsb2FrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ0tleWNsb2FrJyBjb25zdHJ1Y3RvciBtdXN0IGJlIGludm9rZWQgd2l0aCAnbmV3Jy5cIilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycgJiYgIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdLZXljbG9haycgY29uc3RydWN0b3IgbXVzdCBiZSBwcm92aWRlZCB3aXRoIGEgY29uZmlndXJhdGlvbiBvYmplY3QsIG9yIGEgVVJMIHRvIGEgSlNPTiBjb25maWd1cmF0aW9uIGZpbGUuXCIpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdChjb25maWcpKSB7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcGVydGllcyA9ICdvaWRjUHJvdmlkZXInIGluIGNvbmZpZ1xuICAgICAgICAgICAgPyBbJ2NsaWVudElkJ11cbiAgICAgICAgICAgIDogWyd1cmwnLCAncmVhbG0nLCAnY2xpZW50SWQnXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHJlcXVpcmVkUHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKCFjb25maWdbcHJvcGVydHldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgaXMgbWlzc2luZyB0aGUgcmVxdWlyZWQgJyR7cHJvcGVydHl9JyBwcm9wZXJ0eS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrYyA9IHRoaXM7XG4gICAgdmFyIGFkYXB0ZXI7XG4gICAgdmFyIHJlZnJlc2hRdWV1ZSA9IFtdO1xuICAgIHZhciBjYWxsYmFja1N0b3JhZ2U7XG5cbiAgICB2YXIgbG9naW5JZnJhbWUgPSB7XG4gICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2tMaXN0OiBbXSxcbiAgICAgICAgaW50ZXJ2YWw6IDVcbiAgICB9O1xuXG4gICAga2MuZGlkSW5pdGlhbGl6ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHVzZU5vbmNlID0gdHJ1ZTtcbiAgICB2YXIgbG9nSW5mbyA9IGNyZWF0ZUxvZ2dlcihjb25zb2xlLmluZm8pO1xuICAgIHZhciBsb2dXYXJuID0gY3JlYXRlTG9nZ2VyKGNvbnNvbGUud2Fybik7XG5cbiAgICBpZiAoIWdsb2JhbFRoaXMuaXNTZWN1cmVDb250ZXh0KSB7XG4gICAgICAgIGxvZ1dhcm4oXG4gICAgICAgICAgICBcIltLRVlDTE9BS10gS2V5Y2xvYWsgSlMgbXVzdCBiZSB1c2VkIGluIGEgJ3NlY3VyZSBjb250ZXh0JyB0byBmdW5jdGlvbiBwcm9wZXJseSBhcyBpdCByZWxpZXMgb24gYnJvd3NlciBBUElzIHRoYXQgYXJlIG90aGVyd2lzZSBub3QgYXZhaWxhYmxlLlxcblwiICtcbiAgICAgICAgICAgIFwiQ29udGludWluZyB0byBydW4geW91ciBhcHBsaWNhdGlvbiBpbnNlY3VyZWx5IHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGFuZCBicmVha2FnZS5cXG5cXG5cIiArXG4gICAgICAgICAgICBcIkZvciBtb3JlIGluZm9ybWF0aW9uIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU2VjdXJpdHkvU2VjdXJlX0NvbnRleHRzXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBrYy5pbml0ID0gZnVuY3Rpb24gKGluaXRPcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGtjLmRpZEluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgJ0tleWNsb2FrJyBpbnN0YW5jZSBjYW4gb25seSBiZSBpbml0aWFsaXplZCBvbmNlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtjLmRpZEluaXRpYWxpemUgPSB0cnVlO1xuXG4gICAgICAgIGtjLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcblxuICAgICAgICBjYWxsYmFja1N0b3JhZ2UgPSBjcmVhdGVDYWxsYmFja1N0b3JhZ2UoKTtcbiAgICAgICAgdmFyIGFkYXB0ZXJzID0gWydkZWZhdWx0JywgJ2NvcmRvdmEnLCAnY29yZG92YS1uYXRpdmUnXTtcblxuICAgICAgICBpZiAoYWRhcHRlcnMuaW5kZXhPZihpbml0T3B0aW9ucy5hZGFwdGVyKSA+IC0xKSB7XG4gICAgICAgICAgICBhZGFwdGVyID0gbG9hZEFkYXB0ZXIoaW5pdE9wdGlvbnMuYWRhcHRlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluaXRPcHRpb25zLmFkYXB0ZXIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGFkYXB0ZXIgPSBpbml0T3B0aW9ucy5hZGFwdGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5Db3Jkb3ZhIHx8IHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICAgICAgICAgICAgYWRhcHRlciA9IGxvYWRBZGFwdGVyKCdjb3Jkb3ZhJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkYXB0ZXIgPSBsb2FkQWRhcHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0T3B0aW9ucy51c2VOb25jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHVzZU5vbmNlID0gaW5pdE9wdGlvbnMudXNlTm9uY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGluaXRPcHRpb25zLmNoZWNrTG9naW5JZnJhbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsb2dpbklmcmFtZS5lbmFibGUgPSBpbml0T3B0aW9ucy5jaGVja0xvZ2luSWZyYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXRPcHRpb25zLmNoZWNrTG9naW5JZnJhbWVJbnRlcnZhbCkge1xuICAgICAgICAgICAgbG9naW5JZnJhbWUuaW50ZXJ2YWwgPSBpbml0T3B0aW9ucy5jaGVja0xvZ2luSWZyYW1lSW50ZXJ2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5pdE9wdGlvbnMub25Mb2FkID09PSAnbG9naW4tcmVxdWlyZWQnKSB7XG4gICAgICAgICAgICBrYy5sb2dpblJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0T3B0aW9ucy5yZXNwb25zZU1vZGUpIHtcbiAgICAgICAgICAgIGlmIChpbml0T3B0aW9ucy5yZXNwb25zZU1vZGUgPT09ICdxdWVyeScgfHwgaW5pdE9wdGlvbnMucmVzcG9uc2VNb2RlID09PSAnZnJhZ21lbnQnKSB7XG4gICAgICAgICAgICAgICAga2MucmVzcG9uc2VNb2RlID0gaW5pdE9wdGlvbnMucmVzcG9uc2VNb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnSW52YWxpZCB2YWx1ZSBmb3IgcmVzcG9uc2VNb2RlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0T3B0aW9ucy5mbG93KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGluaXRPcHRpb25zLmZsb3cpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdGFuZGFyZCc6XG4gICAgICAgICAgICAgICAgICAgIGtjLnJlc3BvbnNlVHlwZSA9ICdjb2RlJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgICAgICAgICAgICBrYy5yZXNwb25zZVR5cGUgPSAnaWRfdG9rZW4gdG9rZW4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoeWJyaWQnOlxuICAgICAgICAgICAgICAgICAgICBrYy5yZXNwb25zZVR5cGUgPSAnY29kZSBpZF90b2tlbiB0b2tlbic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIHZhbHVlIGZvciBmbG93JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtjLmZsb3cgPSBpbml0T3B0aW9ucy5mbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXRPcHRpb25zLnRpbWVTa2V3ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGtjLnRpbWVTa2V3ID0gaW5pdE9wdGlvbnMudGltZVNrZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZihpbml0T3B0aW9ucy5yZWRpcmVjdFVyaSkge1xuICAgICAgICAgICAga2MucmVkaXJlY3RVcmkgPSBpbml0T3B0aW9ucy5yZWRpcmVjdFVyaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0T3B0aW9ucy5zaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpKSB7XG4gICAgICAgICAgICBrYy5zaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpID0gaW5pdE9wdGlvbnMuc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMuc2lsZW50Q2hlY2tTc29GYWxsYmFjayA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBrYy5zaWxlbnRDaGVja1Nzb0ZhbGxiYWNrID0gaW5pdE9wdGlvbnMuc2lsZW50Q2hlY2tTc29GYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtjLnNpbGVudENoZWNrU3NvRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0T3B0aW9ucy5wa2NlTWV0aG9kICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAoaW5pdE9wdGlvbnMucGtjZU1ldGhvZCAhPT0gXCJTMjU2XCIgJiYgaW5pdE9wdGlvbnMucGtjZU1ldGhvZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciBwa2NlTWV0aG9kJywgZXhwZWN0ZWQgJ1MyNTYnIG9yIGZhbHNlIGJ1dCBnb3QgJHtpbml0T3B0aW9ucy5wa2NlTWV0aG9kfS5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAga2MucGtjZU1ldGhvZCA9IGluaXRPcHRpb25zLnBrY2VNZXRob2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrYy5wa2NlTWV0aG9kID0gXCJTMjU2XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGluaXRPcHRpb25zLmVuYWJsZUxvZ2dpbmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAga2MuZW5hYmxlTG9nZ2luZyA9IGluaXRPcHRpb25zLmVuYWJsZUxvZ2dpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrYy5lbmFibGVMb2dnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5pdE9wdGlvbnMubG9nb3V0TWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICAgICAgICAgIGtjLmxvZ291dE1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtjLmxvZ291dE1ldGhvZCA9ICdHRVQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0T3B0aW9ucy5zY29wZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGtjLnNjb3BlID0gaW5pdE9wdGlvbnMuc2NvcGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGluaXRPcHRpb25zLmFjclZhbHVlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGtjLmFjclZhbHVlcyA9IGluaXRPcHRpb25zLmFjclZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMubWVzc2FnZVJlY2VpdmVUaW1lb3V0ID09PSAnbnVtYmVyJyAmJiBpbml0T3B0aW9ucy5tZXNzYWdlUmVjZWl2ZVRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICBrYy5tZXNzYWdlUmVjZWl2ZVRpbWVvdXQgPSBpbml0T3B0aW9ucy5tZXNzYWdlUmVjZWl2ZVRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrYy5tZXNzYWdlUmVjZWl2ZVRpbWVvdXQgPSAxMDAwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2MucmVzcG9uc2VNb2RlKSB7XG4gICAgICAgICAgICBrYy5yZXNwb25zZU1vZGUgPSAnZnJhZ21lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2MucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBrYy5yZXNwb25zZVR5cGUgPSAnY29kZSc7XG4gICAgICAgICAgICBrYy5mbG93ID0gJ3N0YW5kYXJkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xuXG4gICAgICAgIHZhciBpbml0UHJvbWlzZSA9IGNyZWF0ZVByb21pc2UoKTtcbiAgICAgICAgaW5pdFByb21pc2UucHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAga2Mub25SZWFkeSAmJiBrYy5vblJlYWR5KGtjLmF1dGhlbnRpY2F0ZWQpO1xuICAgICAgICAgICAgcHJvbWlzZS5zZXRTdWNjZXNzKGtjLmF1dGhlbnRpY2F0ZWQpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgcHJvbWlzZS5zZXRFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjb25maWdQcm9taXNlID0gbG9hZENvbmZpZygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uTG9hZCgpIHtcbiAgICAgICAgICAgIHZhciBkb0xvZ2luID0gZnVuY3Rpb24ocHJvbXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9tcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9tcHQgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluaXRPcHRpb25zLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGluaXRPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2MubG9naW4ob3B0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRQcm9taXNlLnNldFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFByb21pc2Uuc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hlY2tTc29TaWxlbnRseSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpZnJtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgc3JjID0gYXdhaXQga2MuY3JlYXRlTG9naW5Vcmwoe3Byb21wdDogJ25vbmUnLCByZWRpcmVjdFVyaToga2Muc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaX0pO1xuICAgICAgICAgICAgICAgIGlmcm0uc2V0QXR0cmlidXRlKFwic3JjXCIsIHNyYyk7XG4gICAgICAgICAgICAgICAgaWZybS5zZXRBdHRyaWJ1dGUoXCJzYW5kYm94XCIsIFwiYWxsb3ctc3RvcmFnZS1hY2Nlc3MtYnktdXNlci1hY3RpdmF0aW9uIGFsbG93LXNjcmlwdHMgYWxsb3ctc2FtZS1vcmlnaW5cIik7XG4gICAgICAgICAgICAgICAgaWZybS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBcImtleWNsb2FrLXNpbGVudC1jaGVjay1zc29cIik7XG4gICAgICAgICAgICAgICAgaWZybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJtKTtcblxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlQ2FsbGJhY2sgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luIHx8IGlmcm0uY29udGVudFdpbmRvdyAhPT0gZXZlbnQuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgb2F1dGggPSBwYXJzZUNhbGxiYWNrKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQ2FsbGJhY2sob2F1dGgsIGluaXRQcm9taXNlKTtcblxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcm0pO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbWVzc2FnZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG1lc3NhZ2VDYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgc3dpdGNoIChpbml0T3B0aW9ucy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVjay1zc28nOlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9naW5JZnJhbWUuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cENoZWNrTG9naW5JZnJhbWUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrTG9naW5JZnJhbWUoKS50aGVuKGZ1bmN0aW9uICh1bmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1bmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtjLnNpbGVudENoZWNrU3NvUmVkaXJlY3RVcmkgPyBjaGVja1Nzb1NpbGVudGx5KCkgOiBkb0xvZ2luKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRQcm9taXNlLnNldFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0UHJvbWlzZS5zZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtjLnNpbGVudENoZWNrU3NvUmVkaXJlY3RVcmkgPyBjaGVja1Nzb1NpbGVudGx5KCkgOiBkb0xvZ2luKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsb2dpbi1yZXF1aXJlZCc6XG4gICAgICAgICAgICAgICAgICAgIGRvTG9naW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIHZhbHVlIGZvciBvbkxvYWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0luaXQoKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBwYXJzZUNhbGxiYWNrKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCBudWxsLCBjYWxsYmFjay5uZXdVcmwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBDaGVja0xvZ2luSWZyYW1lKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NhbGxiYWNrKGNhbGxiYWNrLCBpbml0UHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRQcm9taXNlLnNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluaXRPcHRpb25zLnRva2VuICYmIGluaXRPcHRpb25zLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIHNldFRva2VuKGluaXRPcHRpb25zLnRva2VuLCBpbml0T3B0aW9ucy5yZWZyZXNoVG9rZW4sIGluaXRPcHRpb25zLmlkVG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvZ2luSWZyYW1lLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR1cENoZWNrTG9naW5JZnJhbWUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tMb2dpbklmcmFtZSgpLnRoZW4oZnVuY3Rpb24gKHVuY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2Mub25BdXRoU3VjY2VzcyAmJiBrYy5vbkF1dGhTdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRQcm9taXNlLnNldFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVDaGVja0lmcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRQcm9taXNlLnNldFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0UHJvbWlzZS5zZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2MudXBkYXRlVG9rZW4oLTEpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrYy5vbkF1dGhTdWNjZXNzICYmIGtjLm9uQXV0aFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRQcm9taXNlLnNldFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtjLm9uQXV0aEVycm9yICYmIGtjLm9uQXV0aEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdE9wdGlvbnMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRQcm9taXNlLnNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbml0T3B0aW9ucy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkxvYWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdFByb21pc2Uuc2V0U3VjY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNoZWNrM3BDb29raWVzU3VwcG9ydGVkKClcbiAgICAgICAgICAgICAgICAudGhlbihwcm9jZXNzSW5pdClcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uZmlnUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHByb21pc2Uuc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGtjLmxvZ2luID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXIubG9naW4ob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21EYXRhKGxlbikge1xuICAgICAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViIENyeXB0byBBUEkgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShsZW4pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNvZGVWZXJpZmllcihsZW4pIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlUmFuZG9tU3RyaW5nKGxlbiwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21TdHJpbmcobGVuLCBhbHBoYWJldCl7XG4gICAgICAgIHZhciByYW5kb21EYXRhID0gZ2VuZXJhdGVSYW5kb21EYXRhKGxlbik7XG4gICAgICAgIHZhciBjaGFycyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGFscGhhYmV0LmNoYXJDb2RlQXQocmFuZG9tRGF0YVtpXSAlIGFscGhhYmV0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2hhcnMpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUGtjZUNoYWxsZW5nZShwa2NlTWV0aG9kLCBjb2RlVmVyaWZpZXIpIHtcbiAgICAgICAgaWYgKHBrY2VNZXRob2QgIT09IFwiUzI1NlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciAncGtjZU1ldGhvZCcsIGV4cGVjdGVkICdTMjU2JyBidXQgZ290ICcke3BrY2VNZXRob2R9Jy5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhc2ggY29kZVZlcmlmaWVyLCB0aGVuIGVuY29kZSBhcyB1cmwtc2FmZSBiYXNlNjQgd2l0aG91dCBwYWRkaW5nXG4gICAgICAgIGNvbnN0IGhhc2hCeXRlcyA9IG5ldyBVaW50OEFycmF5KGF3YWl0IHNoYTI1NkRpZ2VzdChjb2RlVmVyaWZpZXIpKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZEhhc2ggPSBieXRlc1RvQmFzZTY0KGhhc2hCeXRlcylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFw9L2csICcnKTtcblxuICAgICAgICByZXR1cm4gZW5jb2RlZEhhc2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRDbGFpbXNQYXJhbWV0ZXIocmVxdWVzdGVkQWNyKXtcbiAgICAgICAgdmFyIGNsYWltcyA9IHtcbiAgICAgICAgICAgIGlkX3Rva2VuOiB7XG4gICAgICAgICAgICAgICAgYWNyOiByZXF1ZXN0ZWRBY3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY2xhaW1zKTtcbiAgICB9XG5cbiAgICBrYy5jcmVhdGVMb2dpblVybCA9IGFzeW5jIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gY3JlYXRlVVVJRCgpO1xuICAgICAgICB2YXIgbm9uY2UgPSBjcmVhdGVVVUlEKCk7XG5cbiAgICAgICAgdmFyIHJlZGlyZWN0VXJpID0gYWRhcHRlci5yZWRpcmVjdFVyaShvcHRpb25zKTtcblxuICAgICAgICB2YXIgY2FsbGJhY2tTdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5vbmNlOiBub25jZSxcbiAgICAgICAgICAgIHJlZGlyZWN0VXJpOiBlbmNvZGVVUklDb21wb25lbnQocmVkaXJlY3RVcmkpLFxuICAgICAgICAgICAgbG9naW5PcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wcm9tcHQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrU3RhdGUucHJvbXB0ID0gb3B0aW9ucy5wcm9tcHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFzZVVybDtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hY3Rpb24gPT0gJ3JlZ2lzdGVyJykge1xuICAgICAgICAgICAgYmFzZVVybCA9IGtjLmVuZHBvaW50cy5yZWdpc3RlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVybCA9IGtjLmVuZHBvaW50cy5hdXRob3JpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY29wZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zY29wZSB8fCBrYy5zY29wZTtcbiAgICAgICAgaWYgKCFzY29wZSkge1xuICAgICAgICAgICAgLy8gaWYgc2NvcGUgaXMgbm90IHNldCwgZGVmYXVsdCB0byBcIm9wZW5pZFwiXG4gICAgICAgICAgICBzY29wZSA9IFwib3BlbmlkXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NvcGUuaW5kZXhPZihcIm9wZW5pZFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGlmIG9wZW5pZCBzY29wZSBpcyBtaXNzaW5nLCBwcmVmaXggdGhlIGdpdmVuIHNjb3BlcyB3aXRoIGl0XG4gICAgICAgICAgICBzY29wZSA9IFwib3BlbmlkIFwiICsgc2NvcGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXJsID0gYmFzZVVybFxuICAgICAgICAgICAgKyAnP2NsaWVudF9pZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGtjLmNsaWVudElkKVxuICAgICAgICAgICAgKyAnJnJlZGlyZWN0X3VyaT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHJlZGlyZWN0VXJpKVxuICAgICAgICAgICAgKyAnJnN0YXRlPScgKyBlbmNvZGVVUklDb21wb25lbnQoc3RhdGUpXG4gICAgICAgICAgICArICcmcmVzcG9uc2VfbW9kZT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGtjLnJlc3BvbnNlTW9kZSlcbiAgICAgICAgICAgICsgJyZyZXNwb25zZV90eXBlPScgKyBlbmNvZGVVUklDb21wb25lbnQoa2MucmVzcG9uc2VUeXBlKVxuICAgICAgICAgICAgKyAnJnNjb3BlPScgKyBlbmNvZGVVUklDb21wb25lbnQoc2NvcGUpO1xuICAgICAgICBpZiAodXNlTm9uY2UpIHtcbiAgICAgICAgICAgIHVybCA9IHVybCArICcmbm9uY2U9JyArIGVuY29kZVVSSUNvbXBvbmVudChub25jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb21wdCkge1xuICAgICAgICAgICAgdXJsICs9ICcmcHJvbXB0PScgKyBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5wcm9tcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdXJsICs9ICcmbWF4X2FnZT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMubWF4QWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubG9naW5IaW50KSB7XG4gICAgICAgICAgICB1cmwgKz0gJyZsb2dpbl9oaW50PScgKyBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5sb2dpbkhpbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZHBIaW50KSB7XG4gICAgICAgICAgICB1cmwgKz0gJyZrY19pZHBfaGludD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuaWRwSGludCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFjdGlvbiAmJiBvcHRpb25zLmFjdGlvbiAhPSAncmVnaXN0ZXInKSB7XG4gICAgICAgICAgICB1cmwgKz0gJyZrY19hY3Rpb249JyArIGVuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLmFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxvY2FsZSkge1xuICAgICAgICAgICAgdXJsICs9ICcmdWlfbG9jYWxlcz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWNyKSB7XG4gICAgICAgICAgICB2YXIgY2xhaW1zUGFyYW1ldGVyID0gYnVpbGRDbGFpbXNQYXJhbWV0ZXIob3B0aW9ucy5hY3IpO1xuICAgICAgICAgICAgdXJsICs9ICcmY2xhaW1zPScgKyBlbmNvZGVVUklDb21wb25lbnQoY2xhaW1zUGFyYW1ldGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFjclZhbHVlcykgfHwga2MuYWNyVmFsdWVzKSB7XG4gICAgICAgICAgICB1cmwgKz0gJyZhY3JfdmFsdWVzPScgKyBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5hY3JWYWx1ZXMgfHwga2MuYWNyVmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrYy5wa2NlTWV0aG9kKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IGdlbmVyYXRlQ29kZVZlcmlmaWVyKDk2KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwa2NlQ2hhbGxlbmdlID0gYXdhaXQgZ2VuZXJhdGVQa2NlQ2hhbGxlbmdlKGtjLnBrY2VNZXRob2QsIGNvZGVWZXJpZmllcik7XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFja1N0YXRlLnBrY2VDb2RlVmVyaWZpZXIgPSBjb2RlVmVyaWZpZXI7XG5cbiAgICAgICAgICAgICAgICB1cmwgKz0gJyZjb2RlX2NoYWxsZW5nZT0nICsgcGtjZUNoYWxsZW5nZTtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJyZjb2RlX2NoYWxsZW5nZV9tZXRob2Q9JyArIGtjLnBrY2VNZXRob2Q7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBQS0NFIGNoYWxsZW5nZS5cIiwgeyBjYXVzZTogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFja1N0b3JhZ2UuYWRkKGNhbGxiYWNrU3RhdGUpO1xuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAga2MubG9nb3V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gYWRhcHRlci5sb2dvdXQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAga2MuY3JlYXRlTG9nb3V0VXJsID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGxvZ291dE1ldGhvZCA9IG9wdGlvbnM/LmxvZ291dE1ldGhvZCA/PyBrYy5sb2dvdXRNZXRob2Q7XG4gICAgICAgIGlmIChsb2dvdXRNZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgICAgICAgcmV0dXJuIGtjLmVuZHBvaW50cy5sb2dvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cmwgPSBrYy5lbmRwb2ludHMubG9nb3V0KClcbiAgICAgICAgICAgICsgJz9jbGllbnRfaWQ9JyArIGVuY29kZVVSSUNvbXBvbmVudChrYy5jbGllbnRJZClcbiAgICAgICAgICAgICsgJyZwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk9JyArIGVuY29kZVVSSUNvbXBvbmVudChhZGFwdGVyLnJlZGlyZWN0VXJpKG9wdGlvbnMsIGZhbHNlKSk7XG5cbiAgICAgICAgaWYgKGtjLmlkVG9rZW4pIHtcbiAgICAgICAgICAgIHVybCArPSAnJmlkX3Rva2VuX2hpbnQ9JyArIGVuY29kZVVSSUNvbXBvbmVudChrYy5pZFRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAga2MucmVnaXN0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gYWRhcHRlci5yZWdpc3RlcihvcHRpb25zKTtcbiAgICB9XG5cbiAgICBrYy5jcmVhdGVSZWdpc3RlclVybCA9IGFzeW5jIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5hY3Rpb24gPSAncmVnaXN0ZXInO1xuICAgICAgICByZXR1cm4gYXdhaXQga2MuY3JlYXRlTG9naW5Vcmwob3B0aW9ucyk7XG4gICAgfVxuXG4gICAga2MuY3JlYXRlQWNjb3VudFVybCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlYWxtID0gZ2V0UmVhbG1VcmwoKTtcbiAgICAgICAgdmFyIHVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiByZWFsbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHVybCA9IHJlYWxtXG4gICAgICAgICAgICArICcvYWNjb3VudCdcbiAgICAgICAgICAgICsgJz9yZWZlcnJlcj0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGtjLmNsaWVudElkKVxuICAgICAgICAgICAgKyAnJnJlZmVycmVyX3VyaT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFkYXB0ZXIucmVkaXJlY3RVcmkob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAga2MuYWNjb3VudE1hbmFnZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXIuYWNjb3VudE1hbmFnZW1lbnQoKTtcbiAgICB9XG5cbiAgICBrYy5oYXNSZWFsbVJvbGUgPSBmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICB2YXIgYWNjZXNzID0ga2MucmVhbG1BY2Nlc3M7XG4gICAgICAgIHJldHVybiAhIWFjY2VzcyAmJiBhY2Nlc3Mucm9sZXMuaW5kZXhPZihyb2xlKSA+PSAwO1xuICAgIH1cblxuICAgIGtjLmhhc1Jlc291cmNlUm9sZSA9IGZ1bmN0aW9uKHJvbGUsIHJlc291cmNlKSB7XG4gICAgICAgIGlmICgha2MucmVzb3VyY2VBY2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY2Nlc3MgPSBrYy5yZXNvdXJjZUFjY2Vzc1tyZXNvdXJjZSB8fCBrYy5jbGllbnRJZF07XG4gICAgICAgIHJldHVybiAhIWFjY2VzcyAmJiBhY2Nlc3Mucm9sZXMuaW5kZXhPZihyb2xlKSA+PSAwO1xuICAgIH1cblxuICAgIGtjLmxvYWRVc2VyUHJvZmlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXJsID0gZ2V0UmVhbG1VcmwoKSArICcvYWNjb3VudCc7XG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsICdiZWFyZXIgJyArIGtjLnRva2VuKTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IGNyZWF0ZVByb21pc2UoKTtcblxuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAga2MucHJvZmlsZSA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc2V0U3VjY2VzcyhrYy5wcm9maWxlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVxLnNlbmQoKTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGtjLmxvYWRVc2VySW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXJsID0ga2MuZW5kcG9pbnRzLnVzZXJpbmZvKCk7XG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsICdiZWFyZXIgJyArIGtjLnRva2VuKTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IGNyZWF0ZVByb21pc2UoKTtcblxuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAga2MudXNlckluZm8gPSBKU09OLnBhcnNlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnNldFN1Y2Nlc3Moa2MudXNlckluZm8pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXEuc2VuZCgpO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlLnByb21pc2U7XG4gICAgfVxuXG4gICAga2MuaXNUb2tlbkV4cGlyZWQgPSBmdW5jdGlvbihtaW5WYWxpZGl0eSkge1xuICAgICAgICBpZiAoIWtjLnRva2VuUGFyc2VkIHx8ICgha2MucmVmcmVzaFRva2VuICYmIGtjLmZsb3cgIT0gJ2ltcGxpY2l0JyApKSB7XG4gICAgICAgICAgICB0aHJvdyAnTm90IGF1dGhlbnRpY2F0ZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtjLnRpbWVTa2V3ID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ0luZm8oJ1tLRVlDTE9BS10gVW5hYmxlIHRvIGRldGVybWluZSBpZiB0b2tlbiBpcyBleHBpcmVkIGFzIHRpbWVza2V3IGlzIG5vdCBzZXQnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGlyZXNJbiA9IGtjLnRva2VuUGFyc2VkWydleHAnXSAtIE1hdGguY2VpbChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsga2MudGltZVNrZXc7XG4gICAgICAgIGlmIChtaW5WYWxpZGl0eSkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKG1pblZhbGlkaXR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIG1pblZhbGlkaXR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGlyZXNJbiAtPSBtaW5WYWxpZGl0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwaXJlc0luIDwgMDtcbiAgICB9XG5cbiAgICBrYy51cGRhdGVUb2tlbiA9IGZ1bmN0aW9uKG1pblZhbGlkaXR5KSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xuXG4gICAgICAgIGlmICgha2MucmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICBwcm9taXNlLnNldEVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluVmFsaWRpdHkgPSBtaW5WYWxpZGl0eSB8fCA1O1xuXG4gICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVmcmVzaFRva2VuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWluVmFsaWRpdHkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxvZ0luZm8oJ1tLRVlDTE9BS10gUmVmcmVzaGluZyB0b2tlbjogZm9yY2VkIHJlZnJlc2gnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWtjLnRva2VuUGFyc2VkIHx8IGtjLmlzVG9rZW5FeHBpcmVkKG1pblZhbGlkaXR5KSkge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hUb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgbG9nSW5mbygnW0tFWUNMT0FLXSBSZWZyZXNoaW5nIHRva2VuOiB0b2tlbiBleHBpcmVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRTdWNjZXNzKGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9ICdncmFudF90eXBlPXJlZnJlc2hfdG9rZW4mJyArICdyZWZyZXNoX3Rva2VuPScgKyBrYy5yZWZyZXNoVG9rZW47XG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IGtjLmVuZHBvaW50cy50b2tlbigpO1xuXG4gICAgICAgICAgICAgICAgcmVmcmVzaFF1ZXVlLnB1c2gocHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaFF1ZXVlLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgKz0gJyZjbGllbnRfaWQ9JyArIGVuY29kZVVSSUNvbXBvbmVudChrYy5jbGllbnRJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVMb2NhbCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dJbmZvKCdbS0VZQ0xPQUtdIFRva2VuIHJlZnJlc2hlZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVMb2NhbCA9ICh0aW1lTG9jYWwgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLyAyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlblJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXEucmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb2tlbih0b2tlblJlc3BvbnNlWydhY2Nlc3NfdG9rZW4nXSwgdG9rZW5SZXNwb25zZVsncmVmcmVzaF90b2tlbiddLCB0b2tlblJlc3BvbnNlWydpZF90b2tlbiddLCB0aW1lTG9jYWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtjLm9uQXV0aFJlZnJlc2hTdWNjZXNzICYmIGtjLm9uQXV0aFJlZnJlc2hTdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSByZWZyZXNoUXVldWUucG9wKCk7IHAgIT0gbnVsbDsgcCA9IHJlZnJlc2hRdWV1ZS5wb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5zZXRTdWNjZXNzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nV2FybignW0tFWUNMT0FLXSBGYWlsZWQgdG8gcmVmcmVzaCB0b2tlbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2MuY2xlYXJUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2Mub25BdXRoUmVmcmVzaEVycm9yICYmIGtjLm9uQXV0aFJlZnJlc2hFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gcmVmcmVzaFF1ZXVlLnBvcCgpOyBwICE9IG51bGw7IHAgPSByZWZyZXNoUXVldWUucG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuc2V0RXJyb3IoXCJGYWlsZWQgdG8gcmVmcmVzaCB0b2tlbjogQW4gdW5leHBlY3RlZCBIVFRQIGVycm9yIG9jY3VycmVkIHdoaWxlIGF0dGVtcHRpbmcgdG8gcmVmcmVzaCB0aGUgdG9rZW4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5zZW5kKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvZ2luSWZyYW1lLmVuYWJsZSkge1xuICAgICAgICAgICAgdmFyIGlmcmFtZVByb21pc2UgPSBjaGVja0xvZ2luSWZyYW1lKCk7XG4gICAgICAgICAgICBpZnJhbWVQcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZXhlYygpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnNldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UucHJvbWlzZTtcbiAgICB9XG5cbiAgICBrYy5jbGVhclRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChrYy50b2tlbikge1xuICAgICAgICAgICAgc2V0VG9rZW4obnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICBrYy5vbkF1dGhMb2dvdXQgJiYga2Mub25BdXRoTG9nb3V0KCk7XG4gICAgICAgICAgICBpZiAoa2MubG9naW5SZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIGtjLmxvZ2luKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSZWFsbVVybCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrYy5hdXRoU2VydmVyVXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGtjLmF1dGhTZXJ2ZXJVcmwuY2hhckF0KGtjLmF1dGhTZXJ2ZXJVcmwubGVuZ3RoIC0gMSkgPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtjLmF1dGhTZXJ2ZXJVcmwgKyAncmVhbG1zLycgKyBlbmNvZGVVUklDb21wb25lbnQoa2MucmVhbG0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2MuYXV0aFNlcnZlclVybCArICcvcmVhbG1zLycgKyBlbmNvZGVVUklDb21wb25lbnQoa2MucmVhbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9yaWdpbigpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cubG9jYXRpb24ub3JpZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICsgKHdpbmRvdy5sb2NhdGlvbi5wb3J0ID8gJzonICsgd2luZG93LmxvY2F0aW9uLnBvcnQ6ICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0NhbGxiYWNrKG9hdXRoLCBwcm9taXNlKSB7XG4gICAgICAgIHZhciBjb2RlID0gb2F1dGguY29kZTtcbiAgICAgICAgdmFyIGVycm9yID0gb2F1dGguZXJyb3I7XG4gICAgICAgIHZhciBwcm9tcHQgPSBvYXV0aC5wcm9tcHQ7XG5cbiAgICAgICAgdmFyIHRpbWVMb2NhbCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIGlmIChvYXV0aFsna2NfYWN0aW9uX3N0YXR1cyddKSB7XG4gICAgICAgICAgICBrYy5vbkFjdGlvblVwZGF0ZSAmJiBrYy5vbkFjdGlvblVwZGF0ZShvYXV0aFsna2NfYWN0aW9uX3N0YXR1cyddLCBvYXV0aFsna2NfYWN0aW9uJ10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAocHJvbXB0ICE9ICdub25lJykge1xuICAgICAgICAgICAgICAgIGlmIChvYXV0aC5lcnJvcl9kZXNjcmlwdGlvbiAmJiBvYXV0aC5lcnJvcl9kZXNjcmlwdGlvbiA9PT0gXCJhdXRoZW50aWNhdGlvbl9leHBpcmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2MubG9naW4ob2F1dGgubG9naW5PcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JEYXRhID0geyBlcnJvcjogZXJyb3IsIGVycm9yX2Rlc2NyaXB0aW9uOiBvYXV0aC5lcnJvcl9kZXNjcmlwdGlvbiB9O1xuICAgICAgICAgICAgICAgICAgICBrYy5vbkF1dGhFcnJvciAmJiBrYy5vbkF1dGhFcnJvcihlcnJvckRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlICYmIHByb21pc2Uuc2V0RXJyb3IoZXJyb3JEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UgJiYgcHJvbWlzZS5zZXRTdWNjZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoKGtjLmZsb3cgIT0gJ3N0YW5kYXJkJykgJiYgKG9hdXRoLmFjY2Vzc190b2tlbiB8fCBvYXV0aC5pZF90b2tlbikpIHtcbiAgICAgICAgICAgIGF1dGhTdWNjZXNzKG9hdXRoLmFjY2Vzc190b2tlbiwgbnVsbCwgb2F1dGguaWRfdG9rZW4sIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChrYy5mbG93ICE9ICdpbXBsaWNpdCcpICYmIGNvZGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSAnY29kZT0nICsgY29kZSArICcmZ3JhbnRfdHlwZT1hdXRob3JpemF0aW9uX2NvZGUnO1xuICAgICAgICAgICAgdmFyIHVybCA9IGtjLmVuZHBvaW50cy50b2tlbigpO1xuXG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXEub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuXG4gICAgICAgICAgICBwYXJhbXMgKz0gJyZjbGllbnRfaWQ9JyArIGVuY29kZVVSSUNvbXBvbmVudChrYy5jbGllbnRJZCk7XG4gICAgICAgICAgICBwYXJhbXMgKz0gJyZyZWRpcmVjdF91cmk9JyArIG9hdXRoLnJlZGlyZWN0VXJpO1xuXG4gICAgICAgICAgICBpZiAob2F1dGgucGtjZUNvZGVWZXJpZmllcikge1xuICAgICAgICAgICAgICAgIHBhcmFtcyArPSAnJmNvZGVfdmVyaWZpZXI9JyArIG9hdXRoLnBrY2VDb2RlVmVyaWZpZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMjAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlblJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhTdWNjZXNzKHRva2VuUmVzcG9uc2VbJ2FjY2Vzc190b2tlbiddLCB0b2tlblJlc3BvbnNlWydyZWZyZXNoX3Rva2VuJ10sIHRva2VuUmVzcG9uc2VbJ2lkX3Rva2VuJ10sIGtjLmZsb3cgPT09ICdzdGFuZGFyZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVDaGVja0lmcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAga2Mub25BdXRoRXJyb3IgJiYga2Mub25BdXRoRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgJiYgcHJvbWlzZS5zZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxLnNlbmQocGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGF1dGhTdWNjZXNzKGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGlkVG9rZW4sIGZ1bGZpbGxQcm9taXNlKSB7XG4gICAgICAgICAgICB0aW1lTG9jYWwgPSAodGltZUxvY2FsICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpIC8gMjtcblxuICAgICAgICAgICAgc2V0VG9rZW4oYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgaWRUb2tlbiwgdGltZUxvY2FsKTtcblxuICAgICAgICAgICAgaWYgKHVzZU5vbmNlICYmIChrYy5pZFRva2VuUGFyc2VkICYmIGtjLmlkVG9rZW5QYXJzZWQubm9uY2UgIT0gb2F1dGguc3RvcmVkTm9uY2UpKSB7XG4gICAgICAgICAgICAgICAgbG9nSW5mbygnW0tFWUNMT0FLXSBJbnZhbGlkIG5vbmNlLCBjbGVhcmluZyB0b2tlbicpO1xuICAgICAgICAgICAgICAgIGtjLmNsZWFyVG9rZW4oKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlICYmIHByb21pc2Uuc2V0RXJyb3IoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGZpbGxQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGtjLm9uQXV0aFN1Y2Nlc3MgJiYga2Mub25BdXRoU3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlICYmIHByb21pc2Uuc2V0U3VjY2VzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZENvbmZpZygpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBjcmVhdGVQcm9taXNlKCk7XG4gICAgICAgIHZhciBjb25maWdVcmw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdVcmwgPSBjb25maWc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXR1cE9pZGNFbmRvaW50cyhvaWRjQ29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKCEgb2lkY0NvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBrYy5lbmRwb2ludHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcml6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvYXV0aCc7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSZWFsbVVybCgpICsgJy9wcm90b2NvbC9vcGVuaWQtY29ubmVjdC90b2tlbic7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxvZ291dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvbG9nb3V0JztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTZXNzaW9uSWZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSZWFsbVVybCgpICsgJy9wcm90b2NvbC9vcGVuaWQtY29ubmVjdC9sb2dpbi1zdGF0dXMtaWZyYW1lLmh0bWwnO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlyZFBhcnR5Q29va2llc0lmcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvM3AtY29va2llcy9zdGVwMS5odG1sJztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJlYWxtVXJsKCkgKyAnL3Byb3RvY29sL29wZW5pZC1jb25uZWN0L3JlZ2lzdHJhdGlvbnMnO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1c2VyaW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvdXNlcmluZm8nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAga2MuZW5kcG9pbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICBhdXRob3JpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9pZGNDb25maWd1cmF0aW9uLmF1dGhvcml6YXRpb25fZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvaWRjQ29uZmlndXJhdGlvbi50b2tlbl9lbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbG9nb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2lkY0NvbmZpZ3VyYXRpb24uZW5kX3Nlc3Npb25fZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIk5vdCBzdXBwb3J0ZWQgYnkgdGhlIE9JREMgc2VydmVyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2lkY0NvbmZpZ3VyYXRpb24uZW5kX3Nlc3Npb25fZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2Vzc2lvbklmcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9pZGNDb25maWd1cmF0aW9uLmNoZWNrX3Nlc3Npb25faWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJOb3Qgc3VwcG9ydGVkIGJ5IHRoZSBPSURDIHNlcnZlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9pZGNDb25maWd1cmF0aW9uLmNoZWNrX3Nlc3Npb25faWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnUmVkaXJlY3Rpb24gdG8gXCJSZWdpc3RlciB1c2VyXCIgcGFnZSBub3Qgc3VwcG9ydGVkIGluIHN0YW5kYXJkIE9JREMgbW9kZSc7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVzZXJpbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2lkY0NvbmZpZ3VyYXRpb24udXNlcmluZm9fZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIk5vdCBzdXBwb3J0ZWQgYnkgdGhlIE9JREMgc2VydmVyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2lkY0NvbmZpZ3VyYXRpb24udXNlcmluZm9fZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnVXJsKSB7XG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXEub3BlbignR0VUJywgY29uZmlnVXJsLCB0cnVlKTtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXG4gICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09IDIwMCB8fCBmaWxlTG9hZGVkKHJlcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBKU09OLnBhcnNlKHJlcS5yZXNwb25zZVRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBrYy5hdXRoU2VydmVyVXJsID0gY29uZmlnWydhdXRoLXNlcnZlci11cmwnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtjLnJlYWxtID0gY29uZmlnWydyZWFsbSddO1xuICAgICAgICAgICAgICAgICAgICAgICAga2MuY2xpZW50SWQgPSBjb25maWdbJ3Jlc291cmNlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cE9pZGNFbmRvaW50cyhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc2V0U3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxLnNlbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtjLmNsaWVudElkID0gY29uZmlnLmNsaWVudElkO1xuXG4gICAgICAgICAgICB2YXIgb2lkY1Byb3ZpZGVyID0gY29uZmlnWydvaWRjUHJvdmlkZXInXTtcbiAgICAgICAgICAgIGlmICghb2lkY1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAga2MuYXV0aFNlcnZlclVybCA9IGNvbmZpZy51cmw7XG4gICAgICAgICAgICAgICAga2MucmVhbG0gPSBjb25maWcucmVhbG07XG4gICAgICAgICAgICAgICAgc2V0dXBPaWRjRW5kb2ludHMobnVsbCk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRTdWNjZXNzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2lkY1Byb3ZpZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2lkY1Byb3ZpZGVyQ29uZmlnVXJsO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2lkY1Byb3ZpZGVyLmNoYXJBdChvaWRjUHJvdmlkZXIubGVuZ3RoIC0gMSkgPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvaWRjUHJvdmlkZXJDb25maWdVcmwgPSBvaWRjUHJvdmlkZXIgKyAnLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2lkY1Byb3ZpZGVyQ29uZmlnVXJsID0gb2lkY1Byb3ZpZGVyICsgJy8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXEub3BlbignR0VUJywgb2lkY1Byb3ZpZGVyQ29uZmlnVXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMjAwIHx8IGZpbGVMb2FkZWQocmVxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2lkY1Byb3ZpZGVyQ29uZmlnID0gSlNPTi5wYXJzZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBPaWRjRW5kb2ludHMob2lkY1Byb3ZpZGVyQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRTdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHVwT2lkY0VuZG9pbnRzKG9pZGNQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc2V0U3VjY2VzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlLnByb21pc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsZUxvYWRlZCh4aHIpIHtcbiAgICAgICAgcmV0dXJuIHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2VUZXh0ICYmIHhoci5yZXNwb25zZVVSTC5zdGFydHNXaXRoKCdmaWxlOicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRva2VuKHRva2VuLCByZWZyZXNoVG9rZW4sIGlkVG9rZW4sIHRpbWVMb2NhbCkge1xuICAgICAgICBpZiAoa2MudG9rZW5UaW1lb3V0SGFuZGxlKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoa2MudG9rZW5UaW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGtjLnRva2VuVGltZW91dEhhbmRsZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICBrYy5yZWZyZXNoVG9rZW4gPSByZWZyZXNoVG9rZW47XG4gICAgICAgICAgICBrYy5yZWZyZXNoVG9rZW5QYXJzZWQgPSBkZWNvZGVUb2tlbihyZWZyZXNoVG9rZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGtjLnJlZnJlc2hUb2tlbjtcbiAgICAgICAgICAgIGRlbGV0ZSBrYy5yZWZyZXNoVG9rZW5QYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRUb2tlbikge1xuICAgICAgICAgICAga2MuaWRUb2tlbiA9IGlkVG9rZW47XG4gICAgICAgICAgICBrYy5pZFRva2VuUGFyc2VkID0gZGVjb2RlVG9rZW4oaWRUb2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUga2MuaWRUb2tlbjtcbiAgICAgICAgICAgIGRlbGV0ZSBrYy5pZFRva2VuUGFyc2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBrYy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAga2MudG9rZW5QYXJzZWQgPSBkZWNvZGVUb2tlbih0b2tlbik7XG4gICAgICAgICAgICBrYy5zZXNzaW9uSWQgPSBrYy50b2tlblBhcnNlZC5zaWQ7XG4gICAgICAgICAgICBrYy5hdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGtjLnN1YmplY3QgPSBrYy50b2tlblBhcnNlZC5zdWI7XG4gICAgICAgICAgICBrYy5yZWFsbUFjY2VzcyA9IGtjLnRva2VuUGFyc2VkLnJlYWxtX2FjY2VzcztcbiAgICAgICAgICAgIGtjLnJlc291cmNlQWNjZXNzID0ga2MudG9rZW5QYXJzZWQucmVzb3VyY2VfYWNjZXNzO1xuXG4gICAgICAgICAgICBpZiAodGltZUxvY2FsKSB7XG4gICAgICAgICAgICAgICAga2MudGltZVNrZXcgPSBNYXRoLmZsb29yKHRpbWVMb2NhbCAvIDEwMDApIC0ga2MudG9rZW5QYXJzZWQuaWF0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2MudGltZVNrZXcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ0luZm8oJ1tLRVlDTE9BS10gRXN0aW1hdGVkIHRpbWUgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXIgYW5kIHNlcnZlciBpcyAnICsga2MudGltZVNrZXcgKyAnIHNlY29uZHMnKTtcblxuICAgICAgICAgICAgICAgIGlmIChrYy5vblRva2VuRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwaXJlc0luID0gKGtjLnRva2VuUGFyc2VkWydleHAnXSAtIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsga2MudGltZVNrZXcpICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgbG9nSW5mbygnW0tFWUNMT0FLXSBUb2tlbiBleHBpcmVzIGluICcgKyBNYXRoLnJvdW5kKGV4cGlyZXNJbiAvIDEwMDApICsgJyBzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBpcmVzSW4gPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2Mub25Ub2tlbkV4cGlyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtjLnRva2VuVGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoa2Mub25Ub2tlbkV4cGlyZWQsIGV4cGlyZXNJbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUga2MudG9rZW47XG4gICAgICAgICAgICBkZWxldGUga2MudG9rZW5QYXJzZWQ7XG4gICAgICAgICAgICBkZWxldGUga2Muc3ViamVjdDtcbiAgICAgICAgICAgIGRlbGV0ZSBrYy5yZWFsbUFjY2VzcztcbiAgICAgICAgICAgIGRlbGV0ZSBrYy5yZXNvdXJjZUFjY2VzcztcblxuICAgICAgICAgICAga2MuYXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVVJRCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGNyeXB0by5yYW5kb21VVUlEID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWIgQ3J5cHRvIEFQSSBpcyBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2FsbGJhY2sodXJsKSB7XG4gICAgICAgIHZhciBvYXV0aCA9IHBhcnNlQ2FsbGJhY2tVcmwodXJsKTtcbiAgICAgICAgaWYgKCFvYXV0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9hdXRoU3RhdGUgPSBjYWxsYmFja1N0b3JhZ2UuZ2V0KG9hdXRoLnN0YXRlKTtcblxuICAgICAgICBpZiAob2F1dGhTdGF0ZSkge1xuICAgICAgICAgICAgb2F1dGgudmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgb2F1dGgucmVkaXJlY3RVcmkgPSBvYXV0aFN0YXRlLnJlZGlyZWN0VXJpO1xuICAgICAgICAgICAgb2F1dGguc3RvcmVkTm9uY2UgPSBvYXV0aFN0YXRlLm5vbmNlO1xuICAgICAgICAgICAgb2F1dGgucHJvbXB0ID0gb2F1dGhTdGF0ZS5wcm9tcHQ7XG4gICAgICAgICAgICBvYXV0aC5wa2NlQ29kZVZlcmlmaWVyID0gb2F1dGhTdGF0ZS5wa2NlQ29kZVZlcmlmaWVyO1xuICAgICAgICAgICAgb2F1dGgubG9naW5PcHRpb25zID0gb2F1dGhTdGF0ZS5sb2dpbk9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2F1dGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDYWxsYmFja1VybCh1cmwpIHtcbiAgICAgICAgdmFyIHN1cHBvcnRlZFBhcmFtcztcbiAgICAgICAgc3dpdGNoIChrYy5mbG93KSB7XG4gICAgICAgICAgICBjYXNlICdzdGFuZGFyZCc6XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkUGFyYW1zID0gWydjb2RlJywgJ3N0YXRlJywgJ3Nlc3Npb25fc3RhdGUnLCAna2NfYWN0aW9uX3N0YXR1cycsICdrY19hY3Rpb24nLCAnaXNzJ107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkUGFyYW1zID0gWydhY2Nlc3NfdG9rZW4nLCAndG9rZW5fdHlwZScsICdpZF90b2tlbicsICdzdGF0ZScsICdzZXNzaW9uX3N0YXRlJywgJ2V4cGlyZXNfaW4nLCAna2NfYWN0aW9uX3N0YXR1cycsICdrY19hY3Rpb24nLCAnaXNzJ107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoeWJyaWQnOlxuICAgICAgICAgICAgICAgIHN1cHBvcnRlZFBhcmFtcyA9IFsnYWNjZXNzX3Rva2VuJywgJ3Rva2VuX3R5cGUnLCAnaWRfdG9rZW4nLCAnY29kZScsICdzdGF0ZScsICdzZXNzaW9uX3N0YXRlJywgJ2V4cGlyZXNfaW4nLCAna2NfYWN0aW9uX3N0YXR1cycsICdrY19hY3Rpb24nLCAnaXNzJ107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBwb3J0ZWRQYXJhbXMucHVzaCgnZXJyb3InKTtcbiAgICAgICAgc3VwcG9ydGVkUGFyYW1zLnB1c2goJ2Vycm9yX2Rlc2NyaXB0aW9uJyk7XG4gICAgICAgIHN1cHBvcnRlZFBhcmFtcy5wdXNoKCdlcnJvcl91cmknKTtcblxuICAgICAgICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgICAgIHZhciBmcmFnbWVudEluZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcblxuICAgICAgICB2YXIgbmV3VXJsO1xuICAgICAgICB2YXIgcGFyc2VkO1xuXG4gICAgICAgIGlmIChrYy5yZXNwb25zZU1vZGUgPT09ICdxdWVyeScgJiYgcXVlcnlJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5ld1VybCA9IHVybC5zdWJzdHJpbmcoMCwgcXVlcnlJbmRleCk7XG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZUNhbGxiYWNrUGFyYW1zKHVybC5zdWJzdHJpbmcocXVlcnlJbmRleCArIDEsIGZyYWdtZW50SW5kZXggIT09IC0xID8gZnJhZ21lbnRJbmRleCA6IHVybC5sZW5ndGgpLCBzdXBwb3J0ZWRQYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXJhbXNTdHJpbmcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbmV3VXJsICs9ICc/JyArIHBhcnNlZC5wYXJhbXNTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdVcmwgKz0gdXJsLnN1YnN0cmluZyhmcmFnbWVudEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrYy5yZXNwb25zZU1vZGUgPT09ICdmcmFnbWVudCcgJiYgZnJhZ21lbnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5ld1VybCA9IHVybC5zdWJzdHJpbmcoMCwgZnJhZ21lbnRJbmRleCk7XG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZUNhbGxiYWNrUGFyYW1zKHVybC5zdWJzdHJpbmcoZnJhZ21lbnRJbmRleCArIDEpLCBzdXBwb3J0ZWRQYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXJhbXNTdHJpbmcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbmV3VXJsICs9ICcjJyArIHBhcnNlZC5wYXJhbXNTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkICYmIHBhcnNlZC5vYXV0aFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGtjLmZsb3cgPT09ICdzdGFuZGFyZCcgfHwga2MuZmxvdyA9PT0gJ2h5YnJpZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHBhcnNlZC5vYXV0aFBhcmFtcy5jb2RlIHx8IHBhcnNlZC5vYXV0aFBhcmFtcy5lcnJvcikgJiYgcGFyc2VkLm9hdXRoUGFyYW1zLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5vYXV0aFBhcmFtcy5uZXdVcmwgPSBuZXdVcmw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQub2F1dGhQYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrYy5mbG93ID09PSAnaW1wbGljaXQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwYXJzZWQub2F1dGhQYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcnNlZC5vYXV0aFBhcmFtcy5lcnJvcikgJiYgcGFyc2VkLm9hdXRoUGFyYW1zLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5vYXV0aFBhcmFtcy5uZXdVcmwgPSBuZXdVcmw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQub2F1dGhQYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDYWxsYmFja1BhcmFtcyhwYXJhbXNTdHJpbmcsIHN1cHBvcnRlZFBhcmFtcykge1xuICAgICAgICB2YXIgcCA9IHBhcmFtc1N0cmluZy5zcGxpdCgnJicpO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgcGFyYW1zU3RyaW5nOiAnJyxcbiAgICAgICAgICAgIG9hdXRoUGFyYW1zOiB7fVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNwbGl0ID0gcFtpXS5pbmRleE9mKFwiPVwiKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwW2ldLnNsaWNlKDAsIHNwbGl0KTtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRQYXJhbXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5vYXV0aFBhcmFtc1trZXldID0gcFtpXS5zbGljZShzcGxpdCArIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnBhcmFtc1N0cmluZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhcmFtc1N0cmluZyArPSAnJic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXJhbXNTdHJpbmcgKz0gcFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb21pc2UoKSB7XG4gICAgICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmF0aXZlIFByb21pc2Ugd2hpY2ggYWxzbyBwcmVzZXJ2ZXMgdGhlXG4gICAgICAgIC8vIGludGVyZmFjZSBvZiB0aGUgY3VzdG9tIHByb21pc2UgdHlwZSBwcmV2aW91c2x5IHVzZWQgYnkgdGhlIEFQSVxuICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICAgIHNldFN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHAucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0RXJyb3I6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHAucmVqZWN0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHAucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHAucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICAvLyBGdW5jdGlvbiB0byBleHRlbmQgZXhpc3RpbmcgbmF0aXZlIFByb21pc2Ugd2l0aCB0aW1lb3V0XG4gICAgZnVuY3Rpb24gYXBwbHlUaW1lb3V0VG9Qcm9taXNlKHByb21pc2UsIHRpbWVvdXQsIGVycm9yTWVzc2FnZSkge1xuICAgICAgICB2YXIgdGltZW91dEhhbmRsZSA9IG51bGw7XG4gICAgICAgIHZhciB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoeyBcImVycm9yXCI6IGVycm9yTWVzc2FnZSB8fCBcIlByb21pc2UgaXMgbm90IHNldHRsZWQgd2l0aGluIHRpbWVvdXQgb2YgXCIgKyB0aW1lb3V0ICsgXCJtc1wiIH0pO1xuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwQ2hlY2tMb2dpbklmcmFtZSgpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBjcmVhdGVQcm9taXNlKCk7XG5cbiAgICAgICAgaWYgKCFsb2dpbklmcmFtZS5lbmFibGUpIHtcbiAgICAgICAgICAgIHByb21pc2Uuc2V0U3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UucHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2dpbklmcmFtZS5pZnJhbWUpIHtcbiAgICAgICAgICAgIHByb21pc2Uuc2V0U3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UucHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgbG9naW5JZnJhbWUuaWZyYW1lID0gaWZyYW1lO1xuXG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhdXRoVXJsID0ga2MuZW5kcG9pbnRzLmF1dGhvcml6ZSgpO1xuICAgICAgICAgICAgaWYgKGF1dGhVcmwuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBsb2dpbklmcmFtZS5pZnJhbWVPcmlnaW4gPSBnZXRPcmlnaW4oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9naW5JZnJhbWUuaWZyYW1lT3JpZ2luID0gYXV0aFVybC5zdWJzdHJpbmcoMCwgYXV0aFVybC5pbmRleE9mKCcvJywgOCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZS5zZXRTdWNjZXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3JjID0ga2MuZW5kcG9pbnRzLmNoZWNrU2Vzc2lvbklmcmFtZSgpO1xuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMgKTtcbiAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc2FuZGJveCcsICdhbGxvdy1zdG9yYWdlLWFjY2Vzcy1ieS11c2VyLWFjdGl2YXRpb24gYWxsb3ctc2NyaXB0cyBhbGxvdy1zYW1lLW9yaWdpbicpO1xuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd0aXRsZScsICdrZXljbG9hay1zZXNzaW9uLWlmcmFtZScgKTtcbiAgICAgICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICAgICAgICB2YXIgbWVzc2FnZUNhbGxiYWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICgoZXZlbnQub3JpZ2luICE9PSBsb2dpbklmcmFtZS5pZnJhbWVPcmlnaW4pIHx8IChsb2dpbklmcmFtZS5pZnJhbWUuY29udGVudFdpbmRvdyAhPT0gZXZlbnQuc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoZXZlbnQuZGF0YSA9PSAndW5jaGFuZ2VkJyB8fCBldmVudC5kYXRhID09ICdjaGFuZ2VkJyB8fCBldmVudC5kYXRhID09ICdlcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhICE9ICd1bmNoYW5nZWQnKSB7XG4gICAgICAgICAgICAgICAga2MuY2xlYXJUb2tlbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gbG9naW5JZnJhbWUuY2FsbGJhY2tMaXN0LnNwbGljZSgwLCBsb2dpbklmcmFtZS5jYWxsYmFja0xpc3QubGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNhbGxiYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhID09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc2V0U3VjY2VzcyhldmVudC5kYXRhID09ICd1bmNoYW5nZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtZXNzYWdlQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlQ2hlY2tJZnJhbWUoKSB7XG4gICAgICAgIGlmIChsb2dpbklmcmFtZS5lbmFibGUpIHtcbiAgICAgICAgICAgIGlmIChrYy50b2tlbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTG9naW5JZnJhbWUoKS50aGVuKGZ1bmN0aW9uKHVuY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlQ2hlY2tJZnJhbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgbG9naW5JZnJhbWUuaW50ZXJ2YWwgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTG9naW5JZnJhbWUoKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xuXG4gICAgICAgIGlmIChsb2dpbklmcmFtZS5pZnJhbWUgJiYgbG9naW5JZnJhbWUuaWZyYW1lT3JpZ2luICkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IGtjLmNsaWVudElkICsgJyAnICsgKGtjLnNlc3Npb25JZCA/IGtjLnNlc3Npb25JZCA6ICcnKTtcbiAgICAgICAgICAgIGxvZ2luSWZyYW1lLmNhbGxiYWNrTGlzdC5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IGxvZ2luSWZyYW1lLmlmcmFtZU9yaWdpbjtcbiAgICAgICAgICAgIGlmIChsb2dpbklmcmFtZS5jYWxsYmFja0xpc3QubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dpbklmcmFtZS5pZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLnNldFN1Y2Nlc3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlLnByb21pc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2szcENvb2tpZXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xuXG4gICAgICAgIGlmICgobG9naW5JZnJhbWUuZW5hYmxlIHx8IGtjLnNpbGVudENoZWNrU3NvUmVkaXJlY3RVcmkpICYmIHR5cGVvZiBrYy5lbmRwb2ludHMudGhpcmRQYXJ0eUNvb2tpZXNJZnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIGtjLmVuZHBvaW50cy50aGlyZFBhcnR5Q29va2llc0lmcmFtZSgpKTtcbiAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3NhbmRib3gnLCAnYWxsb3ctc3RvcmFnZS1hY2Nlc3MtYnktdXNlci1hY3RpdmF0aW9uIGFsbG93LXNjcmlwdHMgYWxsb3ctc2FtZS1vcmlnaW4nKTtcbiAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ2tleWNsb2FrLTNwLWNoZWNrLWlmcmFtZScgKTtcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gICAgICAgICAgICB2YXIgbWVzc2FnZUNhbGxiYWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnRXaW5kb3cgIT09IGV2ZW50LnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEgIT09IFwic3VwcG9ydGVkXCIgJiYgZXZlbnQuZGF0YSAhPT0gXCJ1bnN1cHBvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEgPT09IFwidW5zdXBwb3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dXYXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJbS0VZQ0xPQUtdIFlvdXIgYnJvd3NlciBpcyBibG9ja2luZyBhY2Nlc3MgdG8gM3JkLXBhcnR5IGNvb2tpZXMsIHRoaXMgbWVhbnM6XFxuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgLSBJdCBpcyBub3QgcG9zc2libGUgdG8gcmV0cmlldmUgdG9rZW5zIHdpdGhvdXQgcmVkaXJlY3RpbmcgdG8gdGhlIEtleWNsb2FrIHNlcnZlciAoYS5rLmEuIG5vIHN1cHBvcnQgZm9yIHNpbGVudCBhdXRoZW50aWNhdGlvbikuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgLSBJdCBpcyBub3QgcG9zc2libGUgdG8gYXV0b21hdGljYWxseSBkZXRlY3QgY2hhbmdlcyB0byB0aGUgc2Vzc2lvbiBzdGF0dXMgKHN1Y2ggYXMgdGhlIHVzZXIgbG9nZ2luZyBvdXQgaW4gYW5vdGhlciB0YWIpLlxcblxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlOiBodHRwczovL3d3dy5rZXljbG9hay5vcmcvc2VjdXJpbmctYXBwcy9qYXZhc2NyaXB0LWFkYXB0ZXIjX21vZGVybl9icm93c2Vyc1wiXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9naW5JZnJhbWUuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrYy5zaWxlbnRDaGVja1Nzb0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrYy5zaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG1lc3NhZ2VDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRTdWNjZXNzKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1lc3NhZ2VDYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZS5zZXRTdWNjZXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXBwbHlUaW1lb3V0VG9Qcm9taXNlKHByb21pc2UucHJvbWlzZSwga2MubWVzc2FnZVJlY2VpdmVUaW1lb3V0LCBcIlRpbWVvdXQgd2hlbiB3YWl0aW5nIGZvciAzcmQgcGFydHkgY2hlY2sgaWZyYW1lIG1lc3NhZ2UuXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRBZGFwdGVyKHR5cGUpIHtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvZ2luOiBhc3luYyBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYXdhaXQga2MuY3JlYXRlTG9naW5Vcmwob3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvbWlzZSgpLnByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGxvZ291dDogYXN5bmMgZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ291dE1ldGhvZCA9IG9wdGlvbnM/LmxvZ291dE1ldGhvZCA/PyBrYy5sb2dvdXRNZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dvdXRNZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGtjLmNyZWF0ZUxvZ291dFVybChvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZm9ybSB0byBzZW5kIFBPU1QgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwibWV0aG9kXCIsIFwiUE9TVFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIiwga2MuY3JlYXRlTG9nb3V0VXJsKG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGRhdGEgdG8gZm9ybSBhcyBoaWRkZW4gaW5wdXQgZmllbGRzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRfdG9rZW5faGludDoga2MuaWRUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9pZDoga2MuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk6IGFkYXB0ZXIucmVkaXJlY3RVcmkob3B0aW9ucywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGZvcm0gdG8gcGFnZSBhbmQgc3VibWl0IGl0IHRvIHBlcmZvcm0gbG9nb3V0IGFuZCByZWRpcmVjdC5cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXI6IGFzeW5jIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihhd2FpdCBrYy5jcmVhdGVSZWdpc3RlclVybChvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm9taXNlKCkucHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYWNjb3VudE1hbmFnZW1lbnQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjY291bnRVcmwgPSBrYy5jcmVhdGVBY2NvdW50VXJsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWNjb3VudFVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYWNjb3VudFVybDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiTm90IHN1cHBvcnRlZCBieSB0aGUgT0lEQyBzZXJ2ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvbWlzZSgpLnByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpOiBmdW5jdGlvbihvcHRpb25zLCBlbmNvZGVIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZUhhc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWRpcmVjdFVyaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVkaXJlY3RVcmk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2MucmVkaXJlY3RVcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrYy5yZWRpcmVjdFVyaTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhdGlvbi5ocmVmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09ICdjb3Jkb3ZhJykge1xuICAgICAgICAgICAgbG9naW5JZnJhbWUuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29yZG92YU9wZW5XaW5kb3dXcmFwcGVyID0gZnVuY3Rpb24obG9naW5VcmwsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuY29yZG92YSAmJiB3aW5kb3cuY29yZG92YS5JbkFwcEJyb3dzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGluYXBwYnJvd3NlciBmb3IgSU9TIGFuZCBBbmRyb2lkIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmNvcmRvdmEuSW5BcHBCcm93c2VyLm9wZW4obG9naW5VcmwsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5vcGVuKGxvZ2luVXJsLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBzaGFsbG93Q2xvbmVDb3Jkb3ZhT3B0aW9ucyA9IGZ1bmN0aW9uICh1c2VyT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5jb3Jkb3ZhT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModXNlck9wdGlvbnMuY29yZG92YU9wdGlvbnMpLnJlZHVjZShmdW5jdGlvbiAob3B0aW9ucywgb3B0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IHVzZXJPcHRpb25zLmNvcmRvdmFPcHRpb25zW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGZvcm1hdENvcmRvdmFPcHRpb25zID0gZnVuY3Rpb24gKGNvcmRvdmFPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvcmRvdmFPcHRpb25zKS5yZWR1Y2UoZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKG9wdGlvbk5hbWUrXCI9XCIrY29yZG92YU9wdGlvbnNbb3B0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgICAgICAgICB9LCBbXSkuam9pbihcIixcIik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY3JlYXRlQ29yZG92YU9wdGlvbnMgPSBmdW5jdGlvbiAodXNlck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29yZG92YU9wdGlvbnMgPSBzaGFsbG93Q2xvbmVDb3Jkb3ZhT3B0aW9ucyh1c2VyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29yZG92YU9wdGlvbnMubG9jYXRpb24gPSAnbm8nO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5wcm9tcHQgPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcmRvdmFPcHRpb25zLmhpZGRlbiA9ICd5ZXMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0Q29yZG92YU9wdGlvbnMoY29yZG92YU9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdldENvcmRvdmFSZWRpcmVjdFVyaSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrYy5yZWRpcmVjdFVyaSB8fCAnaHR0cDovL2xvY2FsaG9zdCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9naW46IGFzeW5jIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBjcmVhdGVQcm9taXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcmRvdmFPcHRpb25zID0gY3JlYXRlQ29yZG92YU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2dpblVybCA9IGF3YWl0IGtjLmNyZWF0ZUxvZ2luVXJsKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0gY29yZG92YU9wZW5XaW5kb3dXcmFwcGVyKGxvZ2luVXJsLCAnX2JsYW5rJywgY29yZG92YU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VCcm93c2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudXJsLmluZGV4T2YoZ2V0Q29yZG92YVJlZGlyZWN0VXJpKCkpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBwYXJzZUNhbGxiYWNrKGV2ZW50LnVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NhbGxiYWNrKGNhbGxiYWNrLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUJyb3dzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVycm9yJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKGdldENvcmRvdmFSZWRpcmVjdFVyaSgpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHBhcnNlQ2FsbGJhY2soZXZlbnQudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NhbGxiYWNrKGNhbGxiYWNrLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VCcm93c2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUJyb3dzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdleGl0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJjbG9zZWRfYnlfdXNlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGxvZ291dDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGNyZWF0ZVByb21pc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9nb3V0VXJsID0ga2MuY3JlYXRlTG9nb3V0VXJsKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0gY29yZG92YU9wZW5XaW5kb3dXcmFwcGVyKGxvZ291dFVybCwgJ19ibGFuaycsICdsb2NhdGlvbj1ubyxoaWRkZW49eWVzLGNsZWFyY2FjaGU9eWVzJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKGdldENvcmRvdmFSZWRpcmVjdFVyaSgpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdsb2FkZXJyb3InLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKGdldENvcmRvdmFSZWRpcmVjdFVyaSgpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2V4aXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrYy5jbGVhclRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zZXRTdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyIDogYXN5bmMgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGNyZWF0ZVByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2lzdGVyVXJsID0gYXdhaXQga2MuY3JlYXRlUmVnaXN0ZXJVcmwoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcmRvdmFPcHRpb25zID0gY3JlYXRlQ29yZG92YU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBjb3Jkb3ZhT3BlbldpbmRvd1dyYXBwZXIocmVnaXN0ZXJVcmwsICdfYmxhbmsnLCBjb3Jkb3ZhT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKGdldENvcmRvdmFSZWRpcmVjdFVyaSgpKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9hdXRoID0gcGFyc2VDYWxsYmFjayhldmVudC51cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDYWxsYmFjayhvYXV0aCwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBhY2NvdW50TWFuYWdlbWVudCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWNjb3VudFVybCA9IGtjLmNyZWF0ZUFjY291bnRVcmwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY2NvdW50VXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IGNvcmRvdmFPcGVuV2luZG93V3JhcHBlcihhY2NvdW50VXJsLCAnX2JsYW5rJywgJ2xvY2F0aW9uPW5vJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudXJsLmluZGV4T2YoZ2V0Q29yZG92YVJlZGlyZWN0VXJpKCkpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIk5vdCBzdXBwb3J0ZWQgYnkgdGhlIE9JREMgc2VydmVyXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RVcmk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldENvcmRvdmFSZWRpcmVjdFVyaSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09ICdjb3Jkb3ZhLW5hdGl2ZScpIHtcbiAgICAgICAgICAgIGxvZ2luSWZyYW1lLmVuYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvZ2luOiBhc3luYyBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9naW5VcmwgPSBhd2FpdCBrYy5jcmVhdGVMb2dpblVybChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICB1bml2ZXJzYWxMaW5rcy5zdWJzY3JpYmUoJ2tleWNsb2FrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXZlcnNhbExpbmtzLnVuc3Vic2NyaWJlKCdrZXljbG9haycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2F1dGggPSBwYXJzZUNhbGxiYWNrKGV2ZW50LnVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQ2FsbGJhY2sob2F1dGgsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIub3BlblVybChsb2dpblVybCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGxvZ291dDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGNyZWF0ZVByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ291dFVybCA9IGtjLmNyZWF0ZUxvZ291dFVybChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICB1bml2ZXJzYWxMaW5rcy5zdWJzY3JpYmUoJ2tleWNsb2FrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXZlcnNhbExpbmtzLnVuc3Vic2NyaWJlKCdrZXljbG9haycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrYy5jbGVhclRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnNldFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLm9wZW5VcmwobG9nb3V0VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UucHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXIgOiBhc3luYyBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaXN0ZXJVcmwgPSBhd2FpdCBrYy5jcmVhdGVSZWdpc3RlclVybChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pdmVyc2FsTGlua3Muc3Vic2NyaWJlKCdrZXljbG9haycgLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdmVyc2FsTGlua3MudW5zdWJzY3JpYmUoJ2tleWNsb2FrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYXV0aCA9IHBhcnNlQ2FsbGJhY2soZXZlbnQudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDYWxsYmFjayhvYXV0aCwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIub3BlblVybChyZWdpc3RlclVybCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnByb21pc2U7XG5cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYWNjb3VudE1hbmFnZW1lbnQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjY291bnRVcmwgPSBrYy5jcmVhdGVBY2NvdW50VXJsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWNjb3VudFVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5vcGVuVXJsKGFjY291bnRVcmwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJOb3Qgc3VwcG9ydGVkIGJ5IHRoZSBPSURDIHNlcnZlclwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVkaXJlY3RVcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlZGlyZWN0VXJpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtjLnJlZGlyZWN0VXJpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2MucmVkaXJlY3RVcmk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwOi8vbG9jYWxob3N0XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyAnaW52YWxpZCBhZGFwdGVyIHR5cGU6ICcgKyB0eXBlO1xuICAgIH1cblxuICAgIGNvbnN0IFNUT1JBR0VfS0VZX1BSRUZJWCA9ICdrYy1jYWxsYmFjay0nO1xuXG4gICAgdmFyIExvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTG9jYWxTdG9yYWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFN0b3JhZ2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdrYy10ZXN0JywgJ3Rlc3QnKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2tjLXRlc3QnKTtcblxuICAgICAgICB2YXIgY3MgPSB0aGlzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIHZhbHVlcyBmcm9tIGxvY2FsIHN0b3JhZ2UgdGhhdCBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY2xlYXJJbnZhbGlkVmFsdWVzKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBnZXRTdG9yZWRFbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBleHBpcnkgdGltZSBmcm9tIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBjb25zdCBleHBpcnkgPSBwYXJzZUV4cGlyeSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIHRoZSB2YWx1ZSBpZiBpdCBpcyBtYWxmb3JtZWQgb3IgZXhwaXJlZC5cbiAgICAgICAgICAgICAgICBpZiAoZXhwaXJ5ID09PSBudWxsIHx8IGV4cGlyeSA8IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwga25vd24gdmFsdWVzIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyQWxsVmFsdWVzKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiBnZXRTdG9yZWRFbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYWxsIGVudHJpZXMgc3RvcmVkIGluIGxvY2FsIHN0b3JhZ2UgdGhhdCBhcmUga25vd24gdG8gYmUgbWFuYWdlZCBieSB0aGlzIGNsYXNzLlxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXk8W3N0cmluZywgdW5rbm93bl0+fSBBbiBhcnJheSBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRTdG9yZWRFbnRyaWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGxvY2FsU3RvcmFnZSkuZmlsdGVyKChba2V5XSkgPT4ga2V5LnN0YXJ0c1dpdGgoU1RPUkFHRV9LRVlfUFJFRklYKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIHRoZSBleHBpcnkgdGltZSBmcm9tIGEgdmFsdWUgc3RvcmVkIGluIGxvY2FsIHN0b3JhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlciB8IG51bGx9IFRoZSBleHBpcnkgdGltZSBpbiBtaWxsaXNlY29uZHMsIG9yIGBudWxsYCBpZiB0aGUgdmFsdWUgaXMgbWFsZm9ybWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VFeHBpcnkodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRWYWx1ZTtcblxuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgdmFsdWUgYXMgSlNPTi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkVmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZXh0cmFjdCB0aGUgJ2V4cGlyZXMnIHByb3BlcnR5LlxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcnNlZFZhbHVlKSAmJiAnZXhwaXJlcycgaW4gcGFyc2VkVmFsdWUgJiYgdHlwZW9mIHBhcnNlZFZhbHVlLmV4cGlyZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlLmV4cGlyZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY3MuZ2V0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBrZXkgPSBTVE9SQUdFX0tFWV9QUkVGSVggKyBzdGF0ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsZWFySW52YWxpZFZhbHVlcygpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNzLmFkZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBjbGVhckludmFsaWRWYWx1ZXMoKTtcblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gU1RPUkFHRV9LRVlfUFJFRklYICsgc3RhdGUuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGV4cGlyeSB0aW1lIHRvIDEgaG91ciBmcm9tIG5vdy5cbiAgICAgICAgICAgICAgICBleHBpcmVzOiBEYXRlLm5vdygpICsgKDYwICogNjAgKiAxMDAwKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdG9yYWdlIGlzIGZ1bGwsIGNsZWFyIGFsbCBrbm93biB2YWx1ZXMgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBjbGVhckFsbFZhbHVlcygpO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgQ29va2llU3RvcmFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29va2llU3RvcmFnZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llU3RvcmFnZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNzID0gdGhpcztcblxuICAgICAgICBjcy5nZXQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0Q29va2llKFNUT1JBR0VfS0VZX1BSRUZJWCArIHN0YXRlKTtcbiAgICAgICAgICAgIHNldENvb2tpZShTVE9SQUdFX0tFWV9QUkVGSVggKyBzdGF0ZSwgJycsIGNvb2tpZUV4cGlyYXRpb24oLTEwMCkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNzLmFkZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBzZXRDb29raWUoU1RPUkFHRV9LRVlfUFJFRklYICsgc3RhdGUuc3RhdGUsIEpTT04uc3RyaW5naWZ5KHN0YXRlKSwgY29va2llRXhwaXJhdGlvbig2MCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNzLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHNldENvb2tpZShrZXksICcnLCBjb29raWVFeHBpcmF0aW9uKC0xMDApKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY29va2llRXhwaXJhdGlvbiA9IGZ1bmN0aW9uIChtaW51dGVzKSB7XG4gICAgICAgICAgICB2YXIgZXhwID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGV4cC5zZXRUaW1lKGV4cC5nZXRUaW1lKCkgKyAobWludXRlcyo2MCoxMDAwKSk7XG4gICAgICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRDb29raWUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGtleSArICc9JztcbiAgICAgICAgICAgIHZhciBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY2FbaV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcobmFtZS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNldENvb2tpZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBleHBpcmF0aW9uRGF0ZSkge1xuICAgICAgICAgICAgdmFyIGNvb2tpZSA9IGtleSArICc9JyArIHZhbHVlICsgJzsgJ1xuICAgICAgICAgICAgICAgICsgJ2V4cGlyZXM9JyArIGV4cGlyYXRpb25EYXRlLnRvVVRDU3RyaW5nKCkgKyAnOyAnO1xuICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrU3RvcmFnZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9jYWxTdG9yYWdlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb29raWVTdG9yYWdlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChrYy5lbmFibGVMb2dnaW5nKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkoY29uc29sZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLZXljbG9haztcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBieXRlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0Jhc2U2NCN0aGVfdW5pY29kZV9wcm9ibGVtXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjQoYnl0ZXMpIHtcbiAgICBjb25zdCBiaW5TdHJpbmcgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5ieXRlcyk7XG4gICAgcmV0dXJuIGJ0b2EoYmluU3RyaW5nKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2RpZ2VzdCNiYXNpY19leGFtcGxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNoYTI1NkRpZ2VzdChtZXNzYWdlKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShtZXNzYWdlKTtcblxuICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBjcnlwdG8uc3VidGxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYiBDcnlwdG8gQVBJIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgZGF0YSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVRva2VuKHRva2VuKSB7XG4gICAgY29uc3QgW2hlYWRlciwgcGF5bG9hZF0gPSB0b2tlbi5zcGxpdChcIi5cIik7XG5cbiAgICBpZiAodHlwZW9mIHBheWxvYWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY29kZSB0b2tlbiwgcGF5bG9hZCBub3QgZm91bmQuXCIpO1xuICAgIH1cblxuICAgIGxldCBkZWNvZGVkO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlZCA9IGJhc2U2NFVybERlY29kZShwYXlsb2FkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIHRva2VuLCBwYXlsb2FkIGlzIG5vdCBhIHZhbGlkIEJhc2U2NFVSTCB2YWx1ZS5cIiwgeyBjYXVzZTogZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY29kZSB0b2tlbiwgcGF5bG9hZCBpcyBub3QgYSB2YWxpZCBKU09OIHZhbHVlLlwiLCB7IGNhdXNlOiBlcnJvciB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFVybERlY29kZShpbnB1dCkge1xuICAgIGxldCBvdXRwdXQgPSBpbnB1dFxuICAgICAgICAucmVwbGFjZUFsbChcIi1cIiwgXCIrXCIpXG4gICAgICAgIC5yZXBsYWNlQWxsKFwiX1wiLCBcIi9cIik7XG5cbiAgICBzd2l0Y2ggKG91dHB1dC5sZW5ndGggJSA0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBvdXRwdXQgKz0gXCI9PVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIG91dHB1dCArPSBcIj1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IG9mIHRoZSBjb3JyZWN0IGxlbmd0aC5cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGI2NERlY29kZVVuaWNvZGUob3V0cHV0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gYXRvYihvdXRwdXQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqL1xuZnVuY3Rpb24gYjY0RGVjb2RlVW5pY29kZShpbnB1dCkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoYXRvYihpbnB1dCkucmVwbGFjZSgvKC4pL2csIChtLCBwKSA9PiB7XG4gICAgICAgIGxldCBjb2RlID0gcC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChjb2RlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGNvZGUgPSBcIjBcIiArIGNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCIlXCIgKyBjb2RlO1xuICAgIH0pKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgaW5wdXQgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIG9wZXJhdGVkIG9uLlxuICogQHBhcmFtIHt1bmtub3dufSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0ICE9PSBudWxsO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/keycloak-js/lib/keycloak.js\n");

/***/ })

};
;